<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<bodyText confidence="0.760283">
b&apos;Proceedings of the 21st International Conference on Computational Linguistics and 44th Annual Meeting of the ACL, pages 761768,
Sydney, July 2006. c
</bodyText>
<sectionHeader confidence="0.529056" genericHeader="abstract">
2006 Association for Computational Linguistics
</sectionHeader>
<title confidence="0.96532">
An End-to-End Discriminative Approach to Machine Translation
</title>
<author confidence="0.994099">
Percy Liang Alexandre Bouchard-Cote Dan Klein Ben Taskar
</author>
<affiliation confidence="0.9955805">
Computer Science Division, EECS Department
University of California at Berkeley
</affiliation>
<address confidence="0.970527">
Berkeley, CA 94720
</address>
<email confidence="0.982089">
{pliang, bouchard, klein, taskar}@cs.berkeley.edu
</email>
<sectionHeader confidence="0.99068" genericHeader="keywords">
Abstract
</sectionHeader>
<bodyText confidence="0.998996823529412">
We present a perceptron-style discriminative ap-
proach to machine translation in which large feature
sets can be exploited. Unlike discriminative rerank-
ing approaches, our system can take advantage of
learned features in all stages of decoding. We first
discuss several challenges to error-driven discrim-
inative approaches. In particular, we explore dif-
ferent ways of updating parameters given a training
example. We find that making frequent but smaller
updates is preferable to making fewer but larger up-
dates. Then, we discuss an array of features and
show both how they quantitatively increase BLEU
score and how they qualitatively interact on spe-
cific examples. One particular feature we investi-
gate is a novel way to introduce learning into the
initial phrase extraction process, which has previ-
ously been entirely heuristic.
</bodyText>
<sectionHeader confidence="0.998213" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.998700555555555">
The generative, noisy-channel paradigm has his-
torically served as the foundation for most of the
work in statistical machine translation (Brown et
al., 1994). At the same time, discriminative meth-
ods have provided substantial improvements over
generative models on a wide range of NLP tasks.
They allow one to easily encode domain knowl-
edge in the form of features. Moreover, param-
eters are tuned to directly minimize error rather
than to maximize joint likelihood, which may not
correspond well to the task objective.
In this paper, we present an end-to-end dis-
criminative approach to machine translation. The
proposed system is phrase-based, as in Koehn et
al. (2003), but uses an online perceptron training
scheme to learn model parameters. Unlike mini-
mum error rate training (Och, 2003), our system is
able to exploit large numbers of specific features
in the same manner as static reranking systems
(Shen et al., 2004; Och et al., 2004). However,
unlike static rerankers, our system does not rely
on a baseline translation system. Instead, it up-
dates based on its own n-best lists. As parameter
estimates improve, the system produces better n-
best lists, which can in turn enable better updates
in future training iterations. In this paper, we fo-
cus on two aspects of the problem of discrimina-
tive translation: the inherent difficulty of learning
from reference translations, and the challenge of
engineering effective features for this task.
Discriminative learning from reference transla-
tions is inherently problematic because standard
discriminative methods need to know which out-
puts are correct and which are not. However, a
proposed translation that differs from a reference
translation need not be incorrect. It may differ
in word choice, literalness, or style, yet be fully
acceptable. Pushing our system to avoid such al-
ternate translations is undesirable. On the other
hand, even if a system produces a reference trans-
lation, it may do so by abusing the hidden struc-
ture (sentence segmentation and alignment). We
can therefore never be entirely sure whether or not
a proposed output is safe to update towards. We
discuss this issue in detail in Section 5, where we
show that conservative updates (which push the
system towards a local variant of the current pre-
diction) are more effective than more aggressive
updates (which try to directly update towards the
reference).
The second major contribution of this work is
an investigation of an array of features for our
model. We show how our features quantitatively
increase BLEU score, as well as how they qual-
itatively interact on specific examples. We first
consider learning weights for individual phrases
and part-of-speech patterns, showing gains from
each. We then present a novel way to parameter-
ize and introduce learning into the initial phrase
extraction process. In particular, we introduce
alignment constellation features, which allow us
to weight phrases based on the word alignment
pattern that led to their extraction. This kind of
</bodyText>
<page confidence="0.986981">
761
</page>
<bodyText confidence="0.996224333333333">
\x0cfeature provides a potential way to initially extract
phrases more aggressively and then later down-
weight undesirable patterns, essentially learning a
weighted extraction heuristic. Finally, we use POS
features to parameterize a distortion model in a
limited distortion decoder (Zens and Ney, 2004;
Tillmann and Zhang, 2005). We show that over-
all, BLEU score increases from 28.4 to 29.6 on
French-English.
</bodyText>
<sectionHeader confidence="0.982634" genericHeader="method">
2 Approach
</sectionHeader>
<subsectionHeader confidence="0.919491">
2.1 Translation as structured classification
</subsectionHeader>
<bodyText confidence="0.998970675675676">
Machine translation can be seen as a structured
classification task, in which the goal is to learn
a mapping from an input (French) sentence x to
an output (English) sentence y. Given this setup,
discriminative methods allow us to define a broad
class of features that operate on (x, y). For ex-
ample, some features would measure the fluency
of y and others would measure the faithfulness of
y as a translation of x.
However, the translation task in this framework
differs from traditional applications of discrimina-
tive structured classification such as POS tagging
and parsing in a fundamental way. Whereas in
POS tagging, there is a one-to-one correspondence
between the words x and the tags y, the correspon-
dence between x and y in machine translation is
not only much more complex, but is in fact un-
known. Therefore, we introduce a hidden corre-
spondence structure h and work with the feature
vector (x, y, h).
The phrase-based model of Koehn et al. (2003)
is an instance of this framework. In their model,
the correspondence h consists of (1) the segmen-
tation of the input sentence into phrases, (2) the
segmentation of the output sentence into the same
number of phrases, and (3) a bijection between
the input and output phrases. The feature vec-
tor (x, y, h) contains four components: the log
probability of the output sentence y under a lan-
guage model, the score of translating x into y
based on a phrase table, a distortion score, and a
length penalty.1 In Section 6, we vastly increase
the number of features to take advantage of the full
power of discriminative training.
Another example of this framework is the hier-
archical model of Chiang (2005). In this model
the correspondence h is a synchronous parse tree
</bodyText>
<page confidence="0.937839">
1
</page>
<bodyText confidence="0.991327888888889">
More components can be added to the feature vector if
additional language models or phrase tables are available.
over input and output sentences, and features in-
clude the scores of various productions used in the
tree.
Given features and a corresponding set of pa-
rameters w, a standard classification rule f is to
return the highest scoring output sentence y, max-
imizing over correspondences h:
</bodyText>
<equation confidence="0.986559">
f(x; w) = argmax
y,h
w (x, y, h). (1)
</equation>
<bodyText confidence="0.986076333333333">
In the phrase-based model, computing the
argmax exactly is intractable, so we approximate
f with beam decoding.
</bodyText>
<subsectionHeader confidence="0.995554">
2.2 Perceptron-based training
</subsectionHeader>
<bodyText confidence="0.999319642857143">
To tune the parameters w of the model, we use the
averaged perceptron algorithm (Collins, 2002) be-
cause of its efficiency and past success on various
NLP tasks (Collins and Roark, 2004; Roark et al.,
2004). In principle, w could have been tuned by
maximizing conditional probability or maximiz-
ing margin. However, these two options require
either marginalization or numerical optimization,
neither of which is tractable over the space of out-
put sentences y and correspondences h. In con-
trast, the perceptron algorithm requires only a de-
coder that computes f(x; w).
Recall the traditional perceptron update rule on
an example (xi, yi) is
</bodyText>
<equation confidence="0.739536">
w w + (xi, yt) (xi, yp), (2)
</equation>
<bodyText confidence="0.9239754">
where yt = yi is the target output and yp =
f(xi; w) = argmaxy w (xi, y) is the predic-
tion using the current parameters w.
We adapt this update rule to work with hidden
variables as follows:
</bodyText>
<equation confidence="0.664441">
w w + (xi, yt, ht) (xi, yp, hp), (3)
</equation>
<bodyText confidence="0.98765675">
where (yp, hp) is the argmax computation in
Equation 1, and (yt, ht) is the target that we up-
date towards. If (yt, ht) is the same argmax com-
putation with the additional constraint that yt =
yi, then Equation 3 can be interpreted as a Viterbi
approximation to the stochastic gradient
EP (h|xi,yi;w)(xi, yi, h)EP (y,h|xi;w)(xi, y, h)
for the following conditional likelihood objective:
</bodyText>
<equation confidence="0.98503765">
P(yi  |xi)
X
h
exp(w (xi, yi, h)).
762
\x0c\x01 \x02 \x03 \x01 \x04
\x05 \x06 \x07 \x08 \t
\x03
\x05 \x0b \x07 \x0c
\x01
\x06 \x0e
\x05
\x07 \x0f
\x01
\x0e
\x01 \x02 \x10 \x11 \x12
\t
\x03 \x13
\x06
\x04
\x03
\x14 \x12
\t \x15
\x03 \x04
\x03
\x01 \x02 \x03 \x01 \x04
\x03 \x13 \x03
\t \x15
\x03 \x04
\x16
\t
\x03 \x17 \x12 \x03 \x11 \x02
\x03 \x13
\x06
\x04
\x03
\x06
\x04 \x12
\t \x15
\x03 \x04 \x02
\t
\x03 \x17 \x12 \x03 \x11 \x02
\x03 \x13
\x06
\x04
\x03
\x14
\x06 \t
\x03 \x17 \x12 \x03 \x11 \x02 \x18 \x01
\t
\x12
\t \x15
\x03 \x04 \x02 \x19
\t
\x01
\x03
\x12
\t
\x03
\x12
\t \x15
\x03 \x04
\x03
\x1a
\x04 \x19 \x12 \x02 \x1b \x01 \x02 \x10 \x11 \x12
\t
\x03 \x13
\x06
\x04
\x03
\x14 \x12
\t \x15
\x03 \x04
\x03
\x1c
\x03 \x18 \x03
\t
\x03 \x04
\x03 \x1b \x01 \x02 \x03 \x01 \x04
\x06 \t
\x03 \x17 \x12 \x03 \x11 \x02 \x18 \x01
\t
\x12
\t \x15
\x03 \x04 \x02 \x19
\t
\x01
\x03
\x12
\t
\x03
\x14 \x12
\t \x15
\x03 \x04
\x03
\x01 \x02 \x10 \x11 \x12
\t
\x01 \x02 \x03 \x01 \x04
\x01 \x02 \x10 \x11 \x12
\t
</equation>
<figureCaption confidence="0.990021">
Figure 1: Given the current prediction (a), there
</figureCaption>
<bodyText confidence="0.999025066666667">
are two possible updates, local (b) and bold (c).
Although the bold update (c) reaches the reference
translation, a bad correspondence is used. The lo-
cal update (b) does not reach the reference, but is
more reasonable than (c).
Discriminative training with hidden variables
has been handled in this probabilistic framework
(Quattoni et al., 2004; Koo and Collins, 2005), but
we choose Equation 3 for efficiency.
It turns out that using the Viterbi approximation
(which we call bold updating) is not always the
best strategy. To appreciate the difficulty, consider
the example in Figure 1. Suppose we make the
prediction (a) with the current set of parameters.
There are often several acceptable output transla-
tions y, for example, (b) and (c). Since (c)s output
matches the reference translation, should we up-
date towards (c)? In this case, the answer is nega-
tive. The problem with (c) is that the correspon-
dence h contains an incorrect alignment (, a).
However, since h is unobserved, the training pro-
cedure has no way of knowing this. While the out-
put in (b) is farther from the reference, its corre-
spondence h is much more reasonable. In short,
it does not suffice for yt to be good; both yt and
ht need to be good. A major challenge in using
the perceptron algorithm for machine translation
is determining the target (yt, ht) in Equation 3.
Section 5 discusses possible targets to update to-
wards.
</bodyText>
<sectionHeader confidence="0.996453" genericHeader="method">
3 Dataset
</sectionHeader>
<bodyText confidence="0.9359615">
Our experiments were done on the French-English
portion of the Europarl corpus (Koehn, 2002),
</bodyText>
<table confidence="0.99013225">
Dataset TRAIN DEV TEST
Years 9901 02 03
# sentences 67K first 1K first 1K
# words (unk.) 715K 10.4K (35) 10.8K (48)
</table>
<tableCaption confidence="0.999214">
Table 1: The Europarl dataset split we used and
</tableCaption>
<bodyText confidence="0.843817882352941">
various statistics on length 515 sentences. The
number of French word tokens is given, along
with the number that were not seen among the
414K total sentences in TRAIN (which includes all
lengths).
which consists of European parliamentary pro-
ceedings from 1996 to 2003.
We split the data into three sets according to
Table 1. TRAIN served two purposes: it was
used to construct the features, and the 515 length
sentences were used for tuning the parameters of
those features. DEV, which consisted of the first
1K length 515 sentences in 2002, was used to
evaluate the performance of the system as we de-
veloped it. Note that the DEV set was not used to
tune any parameters; tuning was done exclusively
on TRAIN. At the end we ran our models once on
</bodyText>
<sectionHeader confidence="0.7218655" genericHeader="method">
TEST to get final numbers.2
4 Models
</sectionHeader>
<bodyText confidence="0.998972416666667">
Our experiments used phrase-based models
(Koehn et al., 2003), which require a translation
table and language model for decoding and
feature computation. To facilitate comparison
with previous work, we created the translation
tables using the same techniques as Koehn et al.
(2003).3 The language model was a Kneser-Ney
interpolated trigram model generated using the
SRILM toolkit (Stolcke, 2002). We built our
own phrase-based beam decoder that can handle
arbitrary features.4 The contributions of features
are incrementally added into the score as decoding
</bodyText>
<page confidence="0.934228">
2
</page>
<bodyText confidence="0.990805777777778">
We also experimented with several combinations of jack-
knifing to prevent overfitting, in which we selected features
on TRAIN-OLD (19961998 Europarl corpus) and tuned the
parameters on TRAIN, or vice-versa. However, it turned out
that using TRAIN-OLD was suboptimal since that data is less
relevant to DEV. Another alternative is to combine TRAIN-
OLD and TRAIN into one dual-purpose dataset. The differ-
ences between this and our current approach were inconclu-
sive.
</bodyText>
<page confidence="0.971764">
3
</page>
<bodyText confidence="0.9968536">
In other words, we used GIZA++ to construct a word
alignment in each direction and a growth heuristic to com-
bine them. We extracted all the substrings that are closed un-
der this high-quality word alignment and computed surface
statistics from cooccurrences counts.
</bodyText>
<page confidence="0.963071">
4
</page>
<bodyText confidence="0.997362">
In our experiments, we used a beam size of 10, which we
found to be only slightly worse than using a beam of 100.
</bodyText>
<page confidence="0.981685">
763
</page>
<bodyText confidence="0.9966785">
\x0cproceeds.
We experimented with two levels of distortion:
monotonic, where the phrasal alignment is mono-
tonic (but word reordering is still possible within
a phrase) and limited distortion, where only ad-
jacent phrases are allowed to exchange positions
(Zens and Ney, 2004). In the future, we plan to ex-
plore our discriminative framework on a full dis-
tortion model (Koehn et al., 2003) or even a hier-
archical model (Chiang, 2005).
Throughout the following experiments, we
trained the perceptron algorithm for 10 iterations.
The weights were initialized to 1 on the trans-
lation table, 1 on the language model (the blan-
ket features in Section 6), and 0 elsewhere. The
next two sections give experiments on the two key
components of a discriminative machine transla-
tion system: choosing the proper update strategy
(Section 5) and including powerful features (Sec-
tion 6).
</bodyText>
<sectionHeader confidence="0.870113" genericHeader="method">
5 Update strategies
</sectionHeader>
<bodyText confidence="0.998390727272727">
This section describes the importance of choosing
a good update strategythe difference in BLEU
score can be as large as 1.2 between different
strategies. An update strategy specifies the target
(yt, ht) that we update towards (Equation 3) given
the current set of parameters and a provided ref-
erence translation (xi, yi). As mentioned in Sec-
tion 2.2, faithful output (i.e. yt = yi) does not
imply that updating towards (yt, ht) is desirable.
In fact, such a constrained target might not even
be reachable by the decoder, for example, if the
reference is very non-literal.
We explored the following three ways to choose
the target (yt, ht):
Bold updating: Update towards the highest
scoring option (y, h), where y is constrained
to be the reference yi but h is unconstrained.
Examples not reachable by the decoder are
skipped.
Local updating: Generate an n-best list using
the current parameters. Update towards the
option with the highest BLEU score.5
</bodyText>
<page confidence="0.937108">
5
</page>
<bodyText confidence="0.995412285714286">
Since BLEU score (k-BLEU with k = 4) involves com-
puting a geometric mean over i-grams, i = 1, . . . , k, it is zero
if the translation does not have at least one k-gram in common
with the reference translation. Since a BLEU score of zero
is both unhelpful for choosing from the n-best and common
when computed on just a single example, we instead used a
smoothed version for choosing the target:
</bodyText>
<equation confidence="0.921674">
P4
i=1
i-BLEU(x,y)
24i+1 .
</equation>
<table confidence="0.992896970588235">
We still report NISTs usual 4-gram BLEU.
\x01 \x02 \x03 \x04 \x05 \x06
\x07 \x04 \x08 \t
\x08 \x03 \x0b \x04
\x0c
\x0e
\x06 \x07 \x08 \x01 \x05 \x0b \x08 \x06 \x0f
\x01 \x05
\x10 \x11 \x12 \x13 \x10 \x14 \x15 \x16 \x17 \x18
\x19 \x1a \x1b \x16 \x1c \x1d
\x01 \x02 \x03 \x04 \x05 \x06
\x07 \x04 \x08 \t
\x08 \x03 \x0b \x04
\x0c
\x0e
\x06 \x07 \x08 \x01 \x05 \x0b \x08 \x06 \x0f
\x01 \x05
\x10 \x11 \x12 \x13 \x10 \x18
\x19 \x1a \x1b \x16 \x1c \x1d
\x07 \x04 \x1e \x04 \x07 \x04 \x01 \t \x04
\x07 \x04 \x1e \x04 \x07 \x04 \x01 \t \x04
\x14 \x15 \x16 \x17 \x1f \x1d \x11 \x11 ! \x19 \x1c &amp;quot;
#
\x08 $ % &amp;
\x0e
\x08 \x06 \x04 \x05 \&apos;
\x04 \x01 \x06
\x04 \x07 \x04 \x1e \x04 \x07 \x04 \x01 \t \x04 \x0f \x05 \x07 \x04 \x08 \t
\x08 \x03 \x0b \x04
#
\x03 $ % &amp; \x0e \x08 \x06 \x04 \x05 \&apos;
\x04 \x01 \x06
\x04 \x07 \x04 \x1e \x04 \x07 \x04 \x01 \t \x04 \x0f \x05 ( \x01 \x07 \x04 \x08 \t
\x08 \x03 \x0b \x04
</table>
<figureCaption confidence="0.737006125">
Figure 2: The three update strategies under two
scenarios.
Hybrid updating: Do a bold update if the ref-
erence is reachable. Otherwise, do a local up-
date.
Figure 2 shows the space of translations
schematically. On each training example, our de-
coder produces an n-best list. The reference trans-
</figureCaption>
<bodyText confidence="0.995853192307692">
lation may or may not be reachable.
Bold updating most resembles the traditional
perceptron update rule (Equation 2). We are en-
sured that the target output y will be correct, al-
though the correspondence h might be bad. An-
other weakness of bold updating is that we might
not make full use of the training data.
Local updating uses every example, but its steps
are more cautious. It can be viewed as dy-
namic reranking, where parameters are updated
using the best option on the n-best list, similar
to standard static reranking. The key difference
is that, unlike static reranking, the parameter up-
dates propagate back to the baseline classifier, so
that the n-best list improves over time. In this re-
gard, dynamic reranking remedies one of the main
weaknesses of static reranking, which is that the
performance of the system is directly limited by
the quality of the baseline classifier.
Hybrid updating combines the two strategies:
it makes full use of the training data as in local
updating, but still tries to make swift progress to-
wards the reference translation as in bold updat-
ing.
We conducted experiments to see which of the
updating strategies worked best. We trained on
</bodyText>
<page confidence="0.998624">
764
</page>
<table confidence="0.998013">
\x0cDecoder Bold Local Hybrid
Monotonic 34.3 34.6 34.5
Limited distortion 33.5 34.7 33.6
</table>
<tableCaption confidence="0.999615">
Table 2: Comparison of BLEU scores between dif-
</tableCaption>
<bodyText confidence="0.997433840909091">
ferent updating strategies for the monotonic and
limited distortion decoders on DEV.
5000 of the 67K available examples, using the
BLANKET+LEX+POS feature set (Section 6). Ta-
ble 2 shows that local updating is the most effec-
tive, especially when using the limited distortion
decoder.
In bold updating, only a small fraction of the
5000 examples (1296 for the monotonic decoder
and 1601 for the limited distortion decoder) had
reachable reference translations, and, therefore,
contributed to parameter updates. One might
therefore hypothesize that local updating performs
better simply because it is able to leverage more
data. This is not the full story, however, since the
hybrid approach (which makes the same number
of updates) performs significantly worse than lo-
cal updating when using the limited distortion de-
coder.
To see the problem with bold updating, recall
the example in Figure 1. Bold updating tries to
reach the reference at all costs, even if it means
abusing the hidden correspondence in the process.
In the example, the alignment (, a) is unreason-
able, but the algorithm has no way to recognize
this. Local updating is much more stable since it
only updates towards sentences in the n-best list.
When using the limited distortion decoder, bold
updating is even more problematic because the
added flexibility of phrase swaps allows more pre-
posterous alignments to be produced. Limited
distortion decoding actually performs worse than
monotonic decoding with bold updating, but bet-
ter with local updating.
Another difference between bold updating and
local updating is that the BLEU score on the train-
ing data is dramatically higher for bold updating
than for local (or hybrid) updating: 80 for the for-
mer versus 40 for the latter. This is not surprising
given that bold updating aggressively tries to ob-
tain the references. However, what is surprising is
that although bold updating appears to be overfit-
ting severely, its BLEU score on the DEV does not
suffer much in the monotonic case.
</bodyText>
<table confidence="0.993521666666667">
Model DEV BLEU TEST BLEU
Monotonic
BLANKET (untuned) 33.0 28.3
BLANKET 33.4 28.4
BLANKET+LEX 35.0 29.2
BLANKET+LEX+POS 35.3 29.6
Pharaoh (MERT) 34.5 28.8
Full-distortion
Pharaoh (MERT) 34.9 29.5
</table>
<tableCaption confidence="0.899007333333333">
Table 3: Main results on our system with differ-
ent feature sets compared to minimum error-rate
trained Pharaoh.
</tableCaption>
<sectionHeader confidence="0.997337" genericHeader="method">
6 Features
</sectionHeader>
<bodyText confidence="0.975358615384615">
This section shows that by adding an array of
expressive features and discriminatively learn-
ing their weights, we can obtain a 2.3 increase
in BLEU score on DEV. We add these fea-
tures incrementally, first tuning blanket features
(Section 6.1), then adding lexical features (Sec-
tion 6.2), and finally adding part-of-speech (POS)
features (Section 6.3). Table 3 summarizes the
performance gains.
For the experiments in this section, we used the
local updating strategy and the monotonic decoder
for efficiency. We train on all 67K of the length 5
15 sentences in TRAIN.6
</bodyText>
<subsectionHeader confidence="0.970245">
6.1 Blanket features
</subsectionHeader>
<bodyText confidence="0.995570611111111">
The blanket features (BLANKET) consist of the
translation log-probability and the language model
log-probability, which are two of the components
of the Pharaoh model (Section 2.1). After discrim-
inative training, the relative weight of these two
features is roughly 2:1, resulting in a BLEU score
increase from 33.0 (setting both weights to 1) to
33.4.
The following simple example gives a flavor
of the discriminative approach. The untuned
system translated the French phrase trente-cinq
langues into five languages in a DEV example.
Although the probability P(five  |trente-cinq) =
0.065 is rightly much smaller than P(thirty-five |
trente-cinq) = 0.279, the language model favors
five languages over thirty-five languages. The
trained system downweights the language model
and recovers the correct translation.
</bodyText>
<page confidence="0.991195">
6
</page>
<bodyText confidence="0.99963225">
We used sentences of length 515 to facilitate compar-
isons with Koehn et al. (2003) and to enable rapid experimen-
tation with various feature sets. Experiments on sentences of
length 550 showed similar gains in performance.
</bodyText>
<page confidence="0.992589">
765
</page>
<sectionHeader confidence="0.290245" genericHeader="method">
\x0c6.2 Lexical features
</sectionHeader>
<bodyText confidence="0.996380166666667">
The blanket features provide a rough guide for
translation, but they are far too coarse to fix spe-
cific mistakes. We therefore add lexical fea-
tures (LEX) to allow for more fine-grained con-
trol. These features come in two varieties. Lexical
phrase features indicate the presence of a specific
translation phrase, such as (y a-t-il, are there), and
lexical language model features indicate the pres-
ence of a specific output n-gram, such as of the.
Lexical language model features have been ex-
ploited successfully in discriminative language
modeling to improve speech recognition perfor-
mance (Roark et al., 2004). We confirm the util-
ity of the two kinds of lexical features: BLAN-
KET+LEX achieves a BLEU score of 35.0, an im-
provement of 1.6 over BLANKET.
To understand the effect of adding lexical fea-
tures, consider the ten with highest and lowest
</bodyText>
<figure confidence="0.926521166666667">
weights after training:
64 any comments ? -55 (des, of)
63 (y a-t-il, are there) -52 (y a-t-il, are there any)
62 there any comments -42 there any of
57 any comments -39 of comments
46 (des, any) -38 of comments ?
</figure>
<bodyText confidence="0.993641444444445">
These features can in fact be traced back to the
following example:
Input y a-t-il des observations ?
B are there any of comments ?
B+L are there any comments ?
The second and third rows are the outputs of
BLANKET (wrong) and BLANKET+LEX (correct),
respectively. The correction can be accredited to
two changes in feature weights. First, the lexical
feature (y a-t-il, are there any) has been assigned
a negative weight and (y a-t-il, are there) a pos-
itive weight to counter the fact that the former
phrase incorrectly had a higher score in the origi-
nal translation table. Second, (des, of) is preferred
over (des, any), even though the former is a better
translation in isolation. This apparent degradation
causes no problems, because when des should ac-
tually be translated to of, these words are usually
embedded in larger phrases, in which case the iso-
lated translation probability plays no role.
Another example of a related phenomenon is
the following:
Input ... pour cela que j ai vote favorablement .
B ... for that i have voted in favour .
B+L ... for this reason i voted in favour .
Counterintuitively, the phrase pair
(j ai, I have) ends up with a very negative
weight. The reason behind this is that in French,
j ai is often used in a paraphrastic construction
which should be translated into the simple past
in English. For that to happen, j ai needs to
be aligned with I. Since (j ai, I) has a small
score compare to (j ai, I have) in the original
translation table, downweighting the latter pair
allows this sentence to be translated correctly.
A general trend is that literal phrase translations
are downweighted. Lessening the pressure to liter-
ally translate certain phrases allows the language
model to fill in the gaps appropriately with suit-
able non-literal translations. This point highlights
the strength of discriminative training: weights are
jointly tuned to account for the intricate interac-
tions between overlapping phrases, which is some-
thing not achievable by estimating the weights di-
rectly from surface statistics.
</bodyText>
<subsectionHeader confidence="0.998132">
6.3 Part-of-speech features
</subsectionHeader>
<bodyText confidence="0.986613833333333">
While lexical features are useful for eliminating
specific errors, they have limited ability to gener-
alize to related phrases. This suggests the use of
similar features which are abstracted to the POS
level.7 In our experiments, we used the TreeTag-
ger POS tagger (Schmid, 1994), which ships pre-
trained on several languages, to map each word
to its majority POS tag. We could also relatively
easily base our features on context-dependent POS
tags: the entire input sentence is available before
decoding begins, and the output sentence is de-
coded left-to-right and could be tagged incremen-
tally.
Where we had lexical phrase features, such
as (la realisation du droit, the right), we now
also have their POS abstractions, for instance
(DT NN IN NN, DT NN). This phrase pair is
undesirable, not because of particular lexical facts
about la realisation, but because dropping a nom-
inal head is generally to be avoided. The lexical
language model features have similar POS coun-
terparts. With these two kinds of POS features,
we obtained an 0.3 increase in BLEU score from
BLANKET+LEX to BLANKET+LEX+POS.
Finally, when we use the limited distortion de-
coder, it is important to learn when to swap adja-
cent phrases. Unlike Pharaoh, which simply has a
uniform penalty for swaps, we would like to use
contextin particular, POS information. For ex-
ample, we would like to know that if a (JJ, JJ)
</bodyText>
<page confidence="0.977829">
7
</page>
<bodyText confidence="0.9263715">
We also tried using word clusters (Brown et al., 1992)
instead of POS but found that POS was more helpful.
</bodyText>
<page confidence="0.925007">
766
</page>
<figure confidence="0.999113125">
\x0csecure
refuge
abri
sur
zero
growth
rate
croissance
zero
,
that
same
,
ce
meme
(a) (b) (c)
</figure>
<figureCaption confidence="0.999874">
Figure 3: Three constellation features with exam-
</figureCaption>
<bodyText confidence="0.999478421052632">
ple phrase pairs. Constellations (a) and (b) have
large positive weights and (c) has a large negative
weight.
phrase is constructed after a (NN, NN) phrase,
they are reasonable candidates for swapping be-
cause of regular word-order differences between
French and English. While the bulk of our results
are presented for the monotonic case, the limited
distortion results of Table 2 use these lexical swap
features; without parameterized swap features, ac-
curacy was below the untuned monotonic baseline.
An interesting statistic is the number of nonzero
feature weights that were learned using each
feature set. BLANKET has only 4 features,
while BLANKET+LEX has 1.55 million features.8
Remarkably, BLANKET+LEX+POS has fewer
featuresonly 1.24 million. This is an effect
of generalization abilityPOS information some-
what reduces the need for specific lexical features.
</bodyText>
<subsectionHeader confidence="0.97346">
6.4 Alignment constellation features
</subsectionHeader>
<bodyText confidence="0.999667526315789">
Koehn et al. (2003) demonstrated that choosing
the appropriate heuristic for extracting phrases is
very important. They showed that the difference
in BLEU score between various heuristics was as
large as 2.0.
The process of phrase extraction is difficult to
optimize in a non-discriminative setting: many
heuristics have been proposed (Koehn et al.,
2003), but it is not obvious which one should be
chosen for a given language pair. We propose a
natural way to handle this part of the translation
pipeline. The idea is to push the learning process
all the way down to the phrase extraction by pa-
rameterizing the phrase extraction heuristic itself.
The heuristics in Koehn et al. (2003) decide
whether to extract a given phrase pair based on the
underlying word alignments (see Figure 3 for three
examples), which we call constellations. Since we
do not know which constellations correspond to
</bodyText>
<page confidence="0.971762">
8
</page>
<bodyText confidence="0.980190666666667">
Both the language model and translation table compo-
nents have two features, one for known words and one for
unknown words.
</bodyText>
<table confidence="0.9691665">
Features -CONST +CONST
BLANKET 31.8 32.2
BLANKET+LEX 32.2 32.5
BLANKET+LEX+POS 32.3 32.5
</table>
<tableCaption confidence="0.878697">
Table 4: DEV BLEU score increase resulting from
adding constellation features.
</tableCaption>
<bodyText confidence="0.995173590909091">
good phrase pairs, we introduce an alignment con-
stellation feature to indicate the presence of a par-
ticular alignment constellation.9
Table 4 details the effect of adding constella-
tion features on top of our previous feature sets.10
We get a minor increase in BLEU score from each
feature set, although there is no gain by adding
POS features in addition to constellation features,
probably because POS and constellation features
provide redundant information for French-English
translations.
It is interesting to look at the constellations with
highest and lowest weights, which are perhaps sur-
prising at first glance. At the top of the list are
word inversions (Figure 3 (a) and (b)), while long
monotonic constellations fall at the bottom of the
list (c). Although monotonic translations are much
more frequent than word inversions in our dataset,
when translations are monotonic, shorter segmen-
tations are preferred. This phenomenon is another
manifestation of the complex interaction of phrase
segmentations.
</bodyText>
<sectionHeader confidence="0.945468" genericHeader="method">
7 Final results
</sectionHeader>
<bodyText confidence="0.9641405">
The last column of Table 3 shows the performance
of our methods on the final TEST set. Our best test
BLEU score is 29.6 using BLANKET+LEX+POS,
an increase of 1.3 BLEU over our untuned feature
set BLANKET. The discrepancy between DEV per-
formance and TEST performance is due to tem-
poral distance from TRAIN and high variance in
BLEU score.11
We also compared our model with Pharaoh
(Koehn et al., 2003). We tuned Pharaohs four pa-
rameters using minimum error rate training (Och,
2003) on DEV.12 We obtained an increase of 0.8
</bodyText>
<page confidence="0.929665">
9
</page>
<bodyText confidence="0.9471255">
As in the POS features, we map each phrase pair to its
majority constellation.
</bodyText>
<page confidence="0.911211">
10
</page>
<bodyText confidence="0.6301495">
Due to time constraints, we ran these experiments on
5000 training examples using bold updating.
</bodyText>
<page confidence="0.997345">
11
</page>
<bodyText confidence="0.9991">
For example, the DEV BLEU score for BLANKET+LEX
ranges from 28.6 to 33.2, depending on which block of 1000
sentences we chose.
</bodyText>
<page confidence="0.992">
12
</page>
<bodyText confidence="0.9959625">
We used the training scripts from the 2006 MT Shared
Task. We still tuned our model parameters on TRAIN and
</bodyText>
<page confidence="0.974735">
767
</page>
<bodyText confidence="0.6765702">
\x0cBLEU over the Pharaoh, run with the monotone
flag.13 Even though we are using a monotonic de-
coder, our best results are still slightly better than
the version of Pharaoh that permits arbitrary dis-
tortion.
</bodyText>
<sectionHeader confidence="0.998691" genericHeader="method">
8 Related work
</sectionHeader>
<bodyText confidence="0.999853785714286">
In machine translation, most discriminative ap-
proaches currently fall into two general categories.
The first approach is to reuse the components of a
generative model, but tune their relative weights in
a discriminative fashion (Och and Ney, 2002; Och,
2003; Chiang, 2005). This approach only works in
practice with a small handful of parameters.
The second approach is to use reranking, in
which a baseline classifier generates an n-best list
of candidate translations, and a separate discrim-
inative classifier chooses amongst them (Shen et
al., 2004; Och et al., 2004). The major limita-
tion of a reranking system is its dependence on
the underlying baseline system, which bounds the
potential improvement from discriminative train-
ing. In machine translation, this limitation is a
real concern; it is common for all translations on
moderately-sized n-best lists to be of poor qual-
ity. For instance, Och et al. (2004) reported that
a 1000-best list was required to achieve perfor-
mance gains from reranking. In contrast, the de-
coder in our system can use the feature weights
learned in the previous iteration.
Tillmann and Zhang (2005) present a discrim-
inative approach based on local models. Their
formulation explicitly decomposed the score of
a translation into a sequence of local decisions,
while our formulation allows global estimation.
</bodyText>
<sectionHeader confidence="0.994683" genericHeader="conclusions">
9 Conclusion
</sectionHeader>
<bodyText confidence="0.945589">
We have presented a novel end-to-end discrimi-
native system for machine translation. We stud-
ied update strategies, an important issue in on-
line discriminative training for MT, and conclude
that making many smaller (conservative) updates
is better than making few large (aggressive) up-
dates. We also investigated the effect of adding
many expressive features, which yielded a 0.8 in-
crease in BLEU score over monotonic Pharaoh.
Acknowledgments We would like to thank our
reviewers for their comments. This work was sup-
only used DEV to optimize the number of training iterations.
</bodyText>
<page confidence="0.997445">
13
</page>
<bodyText confidence="0.9986006">
This result is significant with p-value 0.0585 based on
approximate randomization (Riezler and Maxwell, 2005).
ported by a FQRNT fellowship to second author
and a Microsoft Research New Faculty Fellowship
to the third author.
</bodyText>
<sectionHeader confidence="0.991882" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999815185185185">
Peter F. Brown, Vincent J. Della Pietra, Peter V. deSouza,
Jennifer C. Lai, and Robert L. Mercer. 1992. Class-Based
n-gram Models of Natural Language. Computational Lin-
guistics, 18(4):467479.
Peter F. Brown, Stephen A. Della Pietra, Vincent J. Della
Pietra, and Robert L. Mercer. 1994. The Mathematics
of Statistical Machine Translation: Parameter Estimation.
Computational Linguistics, 19:263311.
David Chiang. 2005. A Hierarchical Phrase-Based Model for
Statistical Machine Translation. In ACL 2005.
Michael Collins and Brian Roark. 2004. Incremental Parsing
with the Perceptron Algorithm. In ACL 2004.
Michael Collins. 2002. Discriminative Training Methods for
Hidden Markov Models: Theory and Experiments with
Perceptron Algorithms. In EMNLP 2002.
Philipp Koehn, Franz Josef Och, and Daniel Marcu. 2003.
Statistical Phrase-Based Translation. In HLT-NAACL
2003.
Philipp Koehn. 2002. Europarl: A Multilingual Corpus for
Evaluation of Machine Translation.
Terry Koo and Michael Collins. 2005. Hidden-Variable Mod-
els for Discriminative Reranking. In EMNLP 2005.
Franz Josef Och and Hermann Ney. 2002. Discriminative
Training and Maximum Entropy Models for Statistical
Machine Translation. In ACL 2002.
Franz Josef Och, Daniel Gildea, Sanjeev Khudanpur, and
Anoop Sarkar. 2004. A Smorgasbord of Features for Sta-
tistical Machine Translation. In HLT-NAACL 2004.
Franz Josef Och. 2003. Minimum Error Rate Training in
Statistical Machine Translation. In ACL 2003.
Ariadna Quattoni, Michael Collins, and Trevor Darrell. 2004.
Conditional Random Fields for Object Recognition. In
NIPS 2004.
Stefan Riezler and John T. Maxwell. 2005. On Some Pit-
falls in Automatic Evaluation and Significance Testing for
MT. In Workshop on Intrinsic and Extrinsic Evaluation
Methods for MT and Summarization (MTSE).
Brian Roark, Murat Saraclar, Michael Collins, and Mark
Johnson. 2004. Discriminative Language Modeling with
Conditional Random Fields and the Perceptron Algorithm.
In ACL 2004.
Helmut Schmid. 1994. Probabilistic Part-of-Speech Tag-
ging Using Decision Trees. In International Conference
on New Methods in Language Processing.
Libin Shen, Anoop Sarkar, and Franz Josef Och. 2004. Dis-
criminative Reranking for Machine Translation. In HLT-
NAACL 2004.
Andreas Stolcke. 2002. SRILM An Extensible Language
Modeling Toolkit. In ICSLP 2002.
Christoph Tillmann and Tong Zhang. 2005. A Localized
Prediction Model for Statistical Machine Translation. In
ACL 2005.
Richard Zens and Hermann Ney. 2004. Improvements in Sta-
tistical Phrase-Based Translation. In HLT-NAACL 2004.
</reference>
<page confidence="0.966794">
768
</page>
<figure confidence="0.253148">
\x0c&apos;
</figure>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.672818">
<note confidence="0.868205">b&apos;Proceedings of the 21st International Conference on Computational Linguistics and 44th Annual Meeting of the ACL, pages 761768, Sydney, July 2006. c 2006 Association for Computational Linguistics</note>
<title confidence="0.99633">An End-to-End Discriminative Approach to Machine Translation</title>
<author confidence="0.999992">Percy Liang Alexandre Bouchard-Cote Dan Klein Ben Taskar</author>
<affiliation confidence="0.9998975">Computer Science Division, EECS Department University of California at Berkeley</affiliation>
<address confidence="0.999952">Berkeley, CA 94720</address>
<email confidence="0.995671">pliang@cs.berkeley.edu</email>
<email confidence="0.995671">bouchard@cs.berkeley.edu</email>
<email confidence="0.995671">klein@cs.berkeley.edu</email>
<email confidence="0.995671">taskar@cs.berkeley.edu</email>
<abstract confidence="0.996928444444444">We present a perceptron-style discriminative approach to machine translation in which large feature sets can be exploited. Unlike discriminative reranking approaches, our system can take advantage of learned features in all stages of decoding. We first discuss several challenges to error-driven discriminative approaches. In particular, we explore different ways of updating parameters given a training example. We find that making frequent but smaller updates is preferable to making fewer but larger updates. Then, we discuss an array of features and show both how they quantitatively increase BLEU score and how they qualitatively interact on specific examples. One particular feature we investigate is a novel way to introduce learning into the initial phrase extraction process, which has previously been entirely heuristic.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Peter F Brown</author>
<author>Vincent J Della Pietra</author>
<author>Peter V deSouza</author>
<author>Jennifer C Lai</author>
<author>Robert L Mercer</author>
</authors>
<title>Class-Based n-gram Models of Natural Language.</title>
<date>1992</date>
<journal>Computational Linguistics,</journal>
<volume>18</volume>
<issue>4</issue>
<contexts>
<context position="26626" citStr="Brown et al., 1992" startWordPosition="4480" endWordPosition="4483">l facts about la realisation, but because dropping a nominal head is generally to be avoided. The lexical language model features have similar POS counterparts. With these two kinds of POS features, we obtained an 0.3 increase in BLEU score from BLANKET+LEX to BLANKET+LEX+POS. Finally, when we use the limited distortion decoder, it is important to learn when to swap adjacent phrases. Unlike Pharaoh, which simply has a uniform penalty for swaps, we would like to use contextin particular, POS information. For example, we would like to know that if a (JJ, JJ) 7 We also tried using word clusters (Brown et al., 1992) instead of POS but found that POS was more helpful. 766 \x0csecure refuge abri sur zero growth rate croissance zero , that same , ce meme (a) (b) (c) Figure 3: Three constellation features with example phrase pairs. Constellations (a) and (b) have large positive weights and (c) has a large negative weight. phrase is constructed after a (NN, NN) phrase, they are reasonable candidates for swapping because of regular word-order differences between French and English. While the bulk of our results are presented for the monotonic case, the limited distortion results of Table 2 use these lexical sw</context>
</contexts>
<marker>Brown, Pietra, deSouza, Lai, Mercer, 1992</marker>
<rawString>Peter F. Brown, Vincent J. Della Pietra, Peter V. deSouza, Jennifer C. Lai, and Robert L. Mercer. 1992. Class-Based n-gram Models of Natural Language. Computational Linguistics, 18(4):467479.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Peter F Brown</author>
<author>Stephen A Della Pietra</author>
<author>Vincent J Della Pietra</author>
<author>Robert L Mercer</author>
</authors>
<title>The Mathematics of Statistical Machine Translation: Parameter Estimation. Computational Linguistics,</title>
<date>1994</date>
<contexts>
<context position="1477" citStr="Brown et al., 1994" startWordPosition="210" endWordPosition="213">rs given a training example. We find that making frequent but smaller updates is preferable to making fewer but larger updates. Then, we discuss an array of features and show both how they quantitatively increase BLEU score and how they qualitatively interact on specific examples. One particular feature we investigate is a novel way to introduce learning into the initial phrase extraction process, which has previously been entirely heuristic. 1 Introduction The generative, noisy-channel paradigm has historically served as the foundation for most of the work in statistical machine translation (Brown et al., 1994). At the same time, discriminative methods have provided substantial improvements over generative models on a wide range of NLP tasks. They allow one to easily encode domain knowledge in the form of features. Moreover, parameters are tuned to directly minimize error rather than to maximize joint likelihood, which may not correspond well to the task objective. In this paper, we present an end-to-end discriminative approach to machine translation. The proposed system is phrase-based, as in Koehn et al. (2003), but uses an online perceptron training scheme to learn model parameters. Unlike minimu</context>
</contexts>
<marker>Brown, Pietra, Pietra, Mercer, 1994</marker>
<rawString>Peter F. Brown, Stephen A. Della Pietra, Vincent J. Della Pietra, and Robert L. Mercer. 1994. The Mathematics of Statistical Machine Translation: Parameter Estimation. Computational Linguistics, 19:263311.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Chiang</author>
</authors>
<title>A Hierarchical Phrase-Based Model for Statistical Machine Translation.</title>
<date>2005</date>
<booktitle>In ACL</booktitle>
<contexts>
<context position="6458" citStr="Chiang (2005)" startWordPosition="1026" endWordPosition="1027">1) the segmentation of the input sentence into phrases, (2) the segmentation of the output sentence into the same number of phrases, and (3) a bijection between the input and output phrases. The feature vector (x, y, h) contains four components: the log probability of the output sentence y under a language model, the score of translating x into y based on a phrase table, a distortion score, and a length penalty.1 In Section 6, we vastly increase the number of features to take advantage of the full power of discriminative training. Another example of this framework is the hierarchical model of Chiang (2005). In this model the correspondence h is a synchronous parse tree 1 More components can be added to the feature vector if additional language models or phrase tables are available. over input and output sentences, and features include the scores of various productions used in the tree. Given features and a corresponding set of parameters w, a standard classification rule f is to return the highest scoring output sentence y, maximizing over correspondences h: f(x; w) = argmax y,h w (x, y, h). (1) In the phrase-based model, computing the argmax exactly is intractable, so we approximate f with bea</context>
<context position="13734" citStr="Chiang, 2005" startWordPosition="2303" endWordPosition="2304">nt and computed surface statistics from cooccurrences counts. 4 In our experiments, we used a beam size of 10, which we found to be only slightly worse than using a beam of 100. 763 \x0cproceeds. We experimented with two levels of distortion: monotonic, where the phrasal alignment is monotonic (but word reordering is still possible within a phrase) and limited distortion, where only adjacent phrases are allowed to exchange positions (Zens and Ney, 2004). In the future, we plan to explore our discriminative framework on a full distortion model (Koehn et al., 2003) or even a hierarchical model (Chiang, 2005). Throughout the following experiments, we trained the perceptron algorithm for 10 iterations. The weights were initialized to 1 on the translation table, 1 on the language model (the blanket features in Section 6), and 0 elsewhere. The next two sections give experiments on the two key components of a discriminative machine translation system: choosing the proper update strategy (Section 5) and including powerful features (Section 6). 5 Update strategies This section describes the importance of choosing a good update strategythe difference in BLEU score can be as large as 1.2 between different</context>
<context position="31389" citStr="Chiang, 2005" startWordPosition="5250" endWordPosition="5251">. 12 We used the training scripts from the 2006 MT Shared Task. We still tuned our model parameters on TRAIN and 767 \x0cBLEU over the Pharaoh, run with the monotone flag.13 Even though we are using a monotonic decoder, our best results are still slightly better than the version of Pharaoh that permits arbitrary distortion. 8 Related work In machine translation, most discriminative approaches currently fall into two general categories. The first approach is to reuse the components of a generative model, but tune their relative weights in a discriminative fashion (Och and Ney, 2002; Och, 2003; Chiang, 2005). This approach only works in practice with a small handful of parameters. The second approach is to use reranking, in which a baseline classifier generates an n-best list of candidate translations, and a separate discriminative classifier chooses amongst them (Shen et al., 2004; Och et al., 2004). The major limitation of a reranking system is its dependence on the underlying baseline system, which bounds the potential improvement from discriminative training. In machine translation, this limitation is a real concern; it is common for all translations on moderately-sized n-best lists to be of </context>
</contexts>
<marker>Chiang, 2005</marker>
<rawString>David Chiang. 2005. A Hierarchical Phrase-Based Model for Statistical Machine Translation. In ACL 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Collins</author>
<author>Brian Roark</author>
</authors>
<title>Incremental Parsing with the Perceptron Algorithm. In</title>
<date>2004</date>
<booktitle>ACL</booktitle>
<contexts>
<context position="7284" citStr="Collins and Roark, 2004" startWordPosition="1163" endWordPosition="1166">entences, and features include the scores of various productions used in the tree. Given features and a corresponding set of parameters w, a standard classification rule f is to return the highest scoring output sentence y, maximizing over correspondences h: f(x; w) = argmax y,h w (x, y, h). (1) In the phrase-based model, computing the argmax exactly is intractable, so we approximate f with beam decoding. 2.2 Perceptron-based training To tune the parameters w of the model, we use the averaged perceptron algorithm (Collins, 2002) because of its efficiency and past success on various NLP tasks (Collins and Roark, 2004; Roark et al., 2004). In principle, w could have been tuned by maximizing conditional probability or maximizing margin. However, these two options require either marginalization or numerical optimization, neither of which is tractable over the space of output sentences y and correspondences h. In contrast, the perceptron algorithm requires only a decoder that computes f(x; w). Recall the traditional perceptron update rule on an example (xi, yi) is w w + (xi, yt) (xi, yp), (2) where yt = yi is the target output and yp = f(xi; w) = argmaxy w (xi, y) is the prediction using the current parameter</context>
</contexts>
<marker>Collins, Roark, 2004</marker>
<rawString>Michael Collins and Brian Roark. 2004. Incremental Parsing with the Perceptron Algorithm. In ACL 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michael Collins</author>
</authors>
<title>Discriminative Training Methods for Hidden Markov Models: Theory and Experiments with Perceptron Algorithms.</title>
<date>2002</date>
<booktitle>In EMNLP</booktitle>
<contexts>
<context position="7195" citStr="Collins, 2002" startWordPosition="1149" endWordPosition="1150">ditional language models or phrase tables are available. over input and output sentences, and features include the scores of various productions used in the tree. Given features and a corresponding set of parameters w, a standard classification rule f is to return the highest scoring output sentence y, maximizing over correspondences h: f(x; w) = argmax y,h w (x, y, h). (1) In the phrase-based model, computing the argmax exactly is intractable, so we approximate f with beam decoding. 2.2 Perceptron-based training To tune the parameters w of the model, we use the averaged perceptron algorithm (Collins, 2002) because of its efficiency and past success on various NLP tasks (Collins and Roark, 2004; Roark et al., 2004). In principle, w could have been tuned by maximizing conditional probability or maximizing margin. However, these two options require either marginalization or numerical optimization, neither of which is tractable over the space of output sentences y and correspondences h. In contrast, the perceptron algorithm requires only a decoder that computes f(x; w). Recall the traditional perceptron update rule on an example (xi, yi) is w w + (xi, yt) (xi, yp), (2) where yt = yi is the target o</context>
</contexts>
<marker>Collins, 2002</marker>
<rawString>Michael Collins. 2002. Discriminative Training Methods for Hidden Markov Models: Theory and Experiments with Perceptron Algorithms. In EMNLP 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Philipp Koehn</author>
<author>Franz Josef Och</author>
<author>Daniel Marcu</author>
</authors>
<date>2003</date>
<contexts>
<context position="1989" citStr="Koehn et al. (2003)" startWordPosition="293" endWordPosition="296">cally served as the foundation for most of the work in statistical machine translation (Brown et al., 1994). At the same time, discriminative methods have provided substantial improvements over generative models on a wide range of NLP tasks. They allow one to easily encode domain knowledge in the form of features. Moreover, parameters are tuned to directly minimize error rather than to maximize joint likelihood, which may not correspond well to the task objective. In this paper, we present an end-to-end discriminative approach to machine translation. The proposed system is phrase-based, as in Koehn et al. (2003), but uses an online perceptron training scheme to learn model parameters. Unlike minimum error rate training (Och, 2003), our system is able to exploit large numbers of specific features in the same manner as static reranking systems (Shen et al., 2004; Och et al., 2004). However, unlike static rerankers, our system does not rely on a baseline translation system. Instead, it updates based on its own n-best lists. As parameter estimates improve, the system produces better nbest lists, which can in turn enable better updates in future training iterations. In this paper, we focus on two aspects </context>
<context position="5760" citStr="Koehn et al. (2003)" startWordPosition="902" endWordPosition="905"> of y and others would measure the faithfulness of y as a translation of x. However, the translation task in this framework differs from traditional applications of discriminative structured classification such as POS tagging and parsing in a fundamental way. Whereas in POS tagging, there is a one-to-one correspondence between the words x and the tags y, the correspondence between x and y in machine translation is not only much more complex, but is in fact unknown. Therefore, we introduce a hidden correspondence structure h and work with the feature vector (x, y, h). The phrase-based model of Koehn et al. (2003) is an instance of this framework. In their model, the correspondence h consists of (1) the segmentation of the input sentence into phrases, (2) the segmentation of the output sentence into the same number of phrases, and (3) a bijection between the input and output phrases. The feature vector (x, y, h) contains four components: the log probability of the output sentence y under a language model, the score of translating x into y based on a phrase table, a distortion score, and a length penalty.1 In Section 6, we vastly increase the number of features to take advantage of the full power of dis</context>
<context position="11953" citStr="Koehn et al., 2003" startWordPosition="2014" endWordPosition="2017">rliamentary proceedings from 1996 to 2003. We split the data into three sets according to Table 1. TRAIN served two purposes: it was used to construct the features, and the 515 length sentences were used for tuning the parameters of those features. DEV, which consisted of the first 1K length 515 sentences in 2002, was used to evaluate the performance of the system as we developed it. Note that the DEV set was not used to tune any parameters; tuning was done exclusively on TRAIN. At the end we ran our models once on TEST to get final numbers.2 4 Models Our experiments used phrase-based models (Koehn et al., 2003), which require a translation table and language model for decoding and feature computation. To facilitate comparison with previous work, we created the translation tables using the same techniques as Koehn et al. (2003).3 The language model was a Kneser-Ney interpolated trigram model generated using the SRILM toolkit (Stolcke, 2002). We built our own phrase-based beam decoder that can handle arbitrary features.4 The contributions of features are incrementally added into the score as decoding 2 We also experimented with several combinations of jackknifing to prevent overfitting, in which we se</context>
<context position="13690" citStr="Koehn et al., 2003" startWordPosition="2293" endWordPosition="2296">at are closed under this high-quality word alignment and computed surface statistics from cooccurrences counts. 4 In our experiments, we used a beam size of 10, which we found to be only slightly worse than using a beam of 100. 763 \x0cproceeds. We experimented with two levels of distortion: monotonic, where the phrasal alignment is monotonic (but word reordering is still possible within a phrase) and limited distortion, where only adjacent phrases are allowed to exchange positions (Zens and Ney, 2004). In the future, we plan to explore our discriminative framework on a full distortion model (Koehn et al., 2003) or even a hierarchical model (Chiang, 2005). Throughout the following experiments, we trained the perceptron algorithm for 10 iterations. The weights were initialized to 1 on the translation table, 1 on the language model (the blanket features in Section 6), and 0 elsewhere. The next two sections give experiments on the two key components of a discriminative machine translation system: choosing the proper update strategy (Section 5) and including powerful features (Section 6). 5 Update strategies This section describes the importance of choosing a good update strategythe difference in BLEU sc</context>
<context position="21887" citStr="Koehn et al. (2003)" startWordPosition="3679" endWordPosition="3682">ng in a BLEU score increase from 33.0 (setting both weights to 1) to 33.4. The following simple example gives a flavor of the discriminative approach. The untuned system translated the French phrase trente-cinq langues into five languages in a DEV example. Although the probability P(five |trente-cinq) = 0.065 is rightly much smaller than P(thirty-five | trente-cinq) = 0.279, the language model favors five languages over thirty-five languages. The trained system downweights the language model and recovers the correct translation. 6 We used sentences of length 515 to facilitate comparisons with Koehn et al. (2003) and to enable rapid experimentation with various feature sets. Experiments on sentences of length 550 showed similar gains in performance. 765 \x0c6.2 Lexical features The blanket features provide a rough guide for translation, but they are far too coarse to fix specific mistakes. We therefore add lexical features (LEX) to allow for more fine-grained control. These features come in two varieties. Lexical phrase features indicate the presence of a specific translation phrase, such as (y a-t-il, are there), and lexical language model features indicate the presence of a specific output n-gram, s</context>
<context position="27747" citStr="Koehn et al. (2003)" startWordPosition="4654" endWordPosition="4657">e presented for the monotonic case, the limited distortion results of Table 2 use these lexical swap features; without parameterized swap features, accuracy was below the untuned monotonic baseline. An interesting statistic is the number of nonzero feature weights that were learned using each feature set. BLANKET has only 4 features, while BLANKET+LEX has 1.55 million features.8 Remarkably, BLANKET+LEX+POS has fewer featuresonly 1.24 million. This is an effect of generalization abilityPOS information somewhat reduces the need for specific lexical features. 6.4 Alignment constellation features Koehn et al. (2003) demonstrated that choosing the appropriate heuristic for extracting phrases is very important. They showed that the difference in BLEU score between various heuristics was as large as 2.0. The process of phrase extraction is difficult to optimize in a non-discriminative setting: many heuristics have been proposed (Koehn et al., 2003), but it is not obvious which one should be chosen for a given language pair. We propose a natural way to handle this part of the translation pipeline. The idea is to push the learning process all the way down to the phrase extraction by parameterizing the phrase </context>
<context position="30344" citStr="Koehn et al., 2003" startWordPosition="5071" endWordPosition="5074">nt than word inversions in our dataset, when translations are monotonic, shorter segmentations are preferred. This phenomenon is another manifestation of the complex interaction of phrase segmentations. 7 Final results The last column of Table 3 shows the performance of our methods on the final TEST set. Our best test BLEU score is 29.6 using BLANKET+LEX+POS, an increase of 1.3 BLEU over our untuned feature set BLANKET. The discrepancy between DEV performance and TEST performance is due to temporal distance from TRAIN and high variance in BLEU score.11 We also compared our model with Pharaoh (Koehn et al., 2003). We tuned Pharaohs four parameters using minimum error rate training (Och, 2003) on DEV.12 We obtained an increase of 0.8 9 As in the POS features, we map each phrase pair to its majority constellation. 10 Due to time constraints, we ran these experiments on 5000 training examples using bold updating. 11 For example, the DEV BLEU score for BLANKET+LEX ranges from 28.6 to 33.2, depending on which block of 1000 sentences we chose. 12 We used the training scripts from the 2006 MT Shared Task. We still tuned our model parameters on TRAIN and 767 \x0cBLEU over the Pharaoh, run with the monotone fl</context>
</contexts>
<marker>Koehn, Och, Marcu, 2003</marker>
<rawString>Philipp Koehn, Franz Josef Och, and Daniel Marcu. 2003.</rawString>
</citation>
<citation valid="true">
<title>Statistical Phrase-Based Translation. In</title>
<date>2003</date>
<booktitle>HLT-NAACL</booktitle>
<contexts>
<context position="1989" citStr="(2003)" startWordPosition="296" endWordPosition="296">as the foundation for most of the work in statistical machine translation (Brown et al., 1994). At the same time, discriminative methods have provided substantial improvements over generative models on a wide range of NLP tasks. They allow one to easily encode domain knowledge in the form of features. Moreover, parameters are tuned to directly minimize error rather than to maximize joint likelihood, which may not correspond well to the task objective. In this paper, we present an end-to-end discriminative approach to machine translation. The proposed system is phrase-based, as in Koehn et al. (2003), but uses an online perceptron training scheme to learn model parameters. Unlike minimum error rate training (Och, 2003), our system is able to exploit large numbers of specific features in the same manner as static reranking systems (Shen et al., 2004; Och et al., 2004). However, unlike static rerankers, our system does not rely on a baseline translation system. Instead, it updates based on its own n-best lists. As parameter estimates improve, the system produces better nbest lists, which can in turn enable better updates in future training iterations. In this paper, we focus on two aspects </context>
<context position="5760" citStr="(2003)" startWordPosition="905" endWordPosition="905">ers would measure the faithfulness of y as a translation of x. However, the translation task in this framework differs from traditional applications of discriminative structured classification such as POS tagging and parsing in a fundamental way. Whereas in POS tagging, there is a one-to-one correspondence between the words x and the tags y, the correspondence between x and y in machine translation is not only much more complex, but is in fact unknown. Therefore, we introduce a hidden correspondence structure h and work with the feature vector (x, y, h). The phrase-based model of Koehn et al. (2003) is an instance of this framework. In their model, the correspondence h consists of (1) the segmentation of the input sentence into phrases, (2) the segmentation of the output sentence into the same number of phrases, and (3) a bijection between the input and output phrases. The feature vector (x, y, h) contains four components: the log probability of the output sentence y under a language model, the score of translating x into y based on a phrase table, a distortion score, and a length penalty.1 In Section 6, we vastly increase the number of features to take advantage of the full power of dis</context>
<context position="12173" citStr="(2003)" startWordPosition="2050" endWordPosition="2050">those features. DEV, which consisted of the first 1K length 515 sentences in 2002, was used to evaluate the performance of the system as we developed it. Note that the DEV set was not used to tune any parameters; tuning was done exclusively on TRAIN. At the end we ran our models once on TEST to get final numbers.2 4 Models Our experiments used phrase-based models (Koehn et al., 2003), which require a translation table and language model for decoding and feature computation. To facilitate comparison with previous work, we created the translation tables using the same techniques as Koehn et al. (2003).3 The language model was a Kneser-Ney interpolated trigram model generated using the SRILM toolkit (Stolcke, 2002). We built our own phrase-based beam decoder that can handle arbitrary features.4 The contributions of features are incrementally added into the score as decoding 2 We also experimented with several combinations of jackknifing to prevent overfitting, in which we selected features on TRAIN-OLD (19961998 Europarl corpus) and tuned the parameters on TRAIN, or vice-versa. However, it turned out that using TRAIN-OLD was suboptimal since that data is less relevant to DEV. Another altern</context>
<context position="21887" citStr="(2003)" startWordPosition="3682" endWordPosition="3682">score increase from 33.0 (setting both weights to 1) to 33.4. The following simple example gives a flavor of the discriminative approach. The untuned system translated the French phrase trente-cinq langues into five languages in a DEV example. Although the probability P(five |trente-cinq) = 0.065 is rightly much smaller than P(thirty-five | trente-cinq) = 0.279, the language model favors five languages over thirty-five languages. The trained system downweights the language model and recovers the correct translation. 6 We used sentences of length 515 to facilitate comparisons with Koehn et al. (2003) and to enable rapid experimentation with various feature sets. Experiments on sentences of length 550 showed similar gains in performance. 765 \x0c6.2 Lexical features The blanket features provide a rough guide for translation, but they are far too coarse to fix specific mistakes. We therefore add lexical features (LEX) to allow for more fine-grained control. These features come in two varieties. Lexical phrase features indicate the presence of a specific translation phrase, such as (y a-t-il, are there), and lexical language model features indicate the presence of a specific output n-gram, s</context>
<context position="27747" citStr="(2003)" startWordPosition="4657" endWordPosition="4657">or the monotonic case, the limited distortion results of Table 2 use these lexical swap features; without parameterized swap features, accuracy was below the untuned monotonic baseline. An interesting statistic is the number of nonzero feature weights that were learned using each feature set. BLANKET has only 4 features, while BLANKET+LEX has 1.55 million features.8 Remarkably, BLANKET+LEX+POS has fewer featuresonly 1.24 million. This is an effect of generalization abilityPOS information somewhat reduces the need for specific lexical features. 6.4 Alignment constellation features Koehn et al. (2003) demonstrated that choosing the appropriate heuristic for extracting phrases is very important. They showed that the difference in BLEU score between various heuristics was as large as 2.0. The process of phrase extraction is difficult to optimize in a non-discriminative setting: many heuristics have been proposed (Koehn et al., 2003), but it is not obvious which one should be chosen for a given language pair. We propose a natural way to handle this part of the translation pipeline. The idea is to push the learning process all the way down to the phrase extraction by parameterizing the phrase </context>
</contexts>
<marker>2003</marker>
<rawString>Statistical Phrase-Based Translation. In HLT-NAACL 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Philipp Koehn</author>
</authors>
<title>Europarl: A Multilingual Corpus for Evaluation of Machine Translation.</title>
<date>2002</date>
<contexts>
<context position="10941" citStr="Koehn, 2002" startWordPosition="1835" endWordPosition="1836">at the correspondence h contains an incorrect alignment (, a). However, since h is unobserved, the training procedure has no way of knowing this. While the output in (b) is farther from the reference, its correspondence h is much more reasonable. In short, it does not suffice for yt to be good; both yt and ht need to be good. A major challenge in using the perceptron algorithm for machine translation is determining the target (yt, ht) in Equation 3. Section 5 discusses possible targets to update towards. 3 Dataset Our experiments were done on the French-English portion of the Europarl corpus (Koehn, 2002), Dataset TRAIN DEV TEST Years 9901 02 03 # sentences 67K first 1K first 1K # words (unk.) 715K 10.4K (35) 10.8K (48) Table 1: The Europarl dataset split we used and various statistics on length 515 sentences. The number of French word tokens is given, along with the number that were not seen among the 414K total sentences in TRAIN (which includes all lengths). which consists of European parliamentary proceedings from 1996 to 2003. We split the data into three sets according to Table 1. TRAIN served two purposes: it was used to construct the features, and the 515 length sentences were used for</context>
</contexts>
<marker>Koehn, 2002</marker>
<rawString>Philipp Koehn. 2002. Europarl: A Multilingual Corpus for Evaluation of Machine Translation.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Terry Koo</author>
<author>Michael Collins</author>
</authors>
<title>Hidden-Variable Models for Discriminative Reranking. In</title>
<date>2005</date>
<booktitle>EMNLP</booktitle>
<contexts>
<context position="9807" citStr="Koo and Collins, 2005" startWordPosition="1636" endWordPosition="1639">2 \x03 \x11 \x02 \x18 \x01 \t \x12 \t \x15 \x03 \x04 \x02 \x19 \t \x01 \x03 \x12 \t \x03 \x14 \x12 \t \x15 \x03 \x04 \x03 \x01 \x02 \x10 \x11 \x12 \t \x01 \x02 \x03 \x01 \x04 \x01 \x02 \x10 \x11 \x12 \t Figure 1: Given the current prediction (a), there are two possible updates, local (b) and bold (c). Although the bold update (c) reaches the reference translation, a bad correspondence is used. The local update (b) does not reach the reference, but is more reasonable than (c). Discriminative training with hidden variables has been handled in this probabilistic framework (Quattoni et al., 2004; Koo and Collins, 2005), but we choose Equation 3 for efficiency. It turns out that using the Viterbi approximation (which we call bold updating) is not always the best strategy. To appreciate the difficulty, consider the example in Figure 1. Suppose we make the prediction (a) with the current set of parameters. There are often several acceptable output translations y, for example, (b) and (c). Since (c)s output matches the reference translation, should we update towards (c)? In this case, the answer is negative. The problem with (c) is that the correspondence h contains an incorrect alignment (, a). However, since </context>
</contexts>
<marker>Koo, Collins, 2005</marker>
<rawString>Terry Koo and Michael Collins. 2005. Hidden-Variable Models for Discriminative Reranking. In EMNLP 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz Josef Och</author>
<author>Hermann Ney</author>
</authors>
<title>Discriminative Training and Maximum Entropy Models for Statistical Machine Translation.</title>
<date>2002</date>
<booktitle>In ACL</booktitle>
<contexts>
<context position="31363" citStr="Och and Ney, 2002" startWordPosition="5244" endWordPosition="5247">ock of 1000 sentences we chose. 12 We used the training scripts from the 2006 MT Shared Task. We still tuned our model parameters on TRAIN and 767 \x0cBLEU over the Pharaoh, run with the monotone flag.13 Even though we are using a monotonic decoder, our best results are still slightly better than the version of Pharaoh that permits arbitrary distortion. 8 Related work In machine translation, most discriminative approaches currently fall into two general categories. The first approach is to reuse the components of a generative model, but tune their relative weights in a discriminative fashion (Och and Ney, 2002; Och, 2003; Chiang, 2005). This approach only works in practice with a small handful of parameters. The second approach is to use reranking, in which a baseline classifier generates an n-best list of candidate translations, and a separate discriminative classifier chooses amongst them (Shen et al., 2004; Och et al., 2004). The major limitation of a reranking system is its dependence on the underlying baseline system, which bounds the potential improvement from discriminative training. In machine translation, this limitation is a real concern; it is common for all translations on moderately-si</context>
</contexts>
<marker>Och, Ney, 2002</marker>
<rawString>Franz Josef Och and Hermann Ney. 2002. Discriminative Training and Maximum Entropy Models for Statistical Machine Translation. In ACL 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz Josef Och</author>
<author>Daniel Gildea</author>
<author>Sanjeev Khudanpur</author>
<author>Anoop Sarkar</author>
</authors>
<title>A Smorgasbord of Features for Statistical Machine Translation. In HLT-NAACL</title>
<date>2004</date>
<contexts>
<context position="2261" citStr="Och et al., 2004" startWordPosition="339" endWordPosition="342">domain knowledge in the form of features. Moreover, parameters are tuned to directly minimize error rather than to maximize joint likelihood, which may not correspond well to the task objective. In this paper, we present an end-to-end discriminative approach to machine translation. The proposed system is phrase-based, as in Koehn et al. (2003), but uses an online perceptron training scheme to learn model parameters. Unlike minimum error rate training (Och, 2003), our system is able to exploit large numbers of specific features in the same manner as static reranking systems (Shen et al., 2004; Och et al., 2004). However, unlike static rerankers, our system does not rely on a baseline translation system. Instead, it updates based on its own n-best lists. As parameter estimates improve, the system produces better nbest lists, which can in turn enable better updates in future training iterations. In this paper, we focus on two aspects of the problem of discriminative translation: the inherent difficulty of learning from reference translations, and the challenge of engineering effective features for this task. Discriminative learning from reference translations is inherently problematic because standard</context>
<context position="31687" citStr="Och et al., 2004" startWordPosition="5296" endWordPosition="5299">t permits arbitrary distortion. 8 Related work In machine translation, most discriminative approaches currently fall into two general categories. The first approach is to reuse the components of a generative model, but tune their relative weights in a discriminative fashion (Och and Ney, 2002; Och, 2003; Chiang, 2005). This approach only works in practice with a small handful of parameters. The second approach is to use reranking, in which a baseline classifier generates an n-best list of candidate translations, and a separate discriminative classifier chooses amongst them (Shen et al., 2004; Och et al., 2004). The major limitation of a reranking system is its dependence on the underlying baseline system, which bounds the potential improvement from discriminative training. In machine translation, this limitation is a real concern; it is common for all translations on moderately-sized n-best lists to be of poor quality. For instance, Och et al. (2004) reported that a 1000-best list was required to achieve performance gains from reranking. In contrast, the decoder in our system can use the feature weights learned in the previous iteration. Tillmann and Zhang (2005) present a discriminative approach b</context>
</contexts>
<marker>Och, Gildea, Khudanpur, Sarkar, 2004</marker>
<rawString>Franz Josef Och, Daniel Gildea, Sanjeev Khudanpur, and Anoop Sarkar. 2004. A Smorgasbord of Features for Statistical Machine Translation. In HLT-NAACL 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz Josef Och</author>
</authors>
<title>Minimum Error Rate Training in Statistical Machine Translation. In</title>
<date>2003</date>
<booktitle>ACL</booktitle>
<contexts>
<context position="2110" citStr="Och, 2003" startWordPosition="314" endWordPosition="315">criminative methods have provided substantial improvements over generative models on a wide range of NLP tasks. They allow one to easily encode domain knowledge in the form of features. Moreover, parameters are tuned to directly minimize error rather than to maximize joint likelihood, which may not correspond well to the task objective. In this paper, we present an end-to-end discriminative approach to machine translation. The proposed system is phrase-based, as in Koehn et al. (2003), but uses an online perceptron training scheme to learn model parameters. Unlike minimum error rate training (Och, 2003), our system is able to exploit large numbers of specific features in the same manner as static reranking systems (Shen et al., 2004; Och et al., 2004). However, unlike static rerankers, our system does not rely on a baseline translation system. Instead, it updates based on its own n-best lists. As parameter estimates improve, the system produces better nbest lists, which can in turn enable better updates in future training iterations. In this paper, we focus on two aspects of the problem of discriminative translation: the inherent difficulty of learning from reference translations, and the ch</context>
<context position="30425" citStr="Och, 2003" startWordPosition="5086" endWordPosition="5087">ions are preferred. This phenomenon is another manifestation of the complex interaction of phrase segmentations. 7 Final results The last column of Table 3 shows the performance of our methods on the final TEST set. Our best test BLEU score is 29.6 using BLANKET+LEX+POS, an increase of 1.3 BLEU over our untuned feature set BLANKET. The discrepancy between DEV performance and TEST performance is due to temporal distance from TRAIN and high variance in BLEU score.11 We also compared our model with Pharaoh (Koehn et al., 2003). We tuned Pharaohs four parameters using minimum error rate training (Och, 2003) on DEV.12 We obtained an increase of 0.8 9 As in the POS features, we map each phrase pair to its majority constellation. 10 Due to time constraints, we ran these experiments on 5000 training examples using bold updating. 11 For example, the DEV BLEU score for BLANKET+LEX ranges from 28.6 to 33.2, depending on which block of 1000 sentences we chose. 12 We used the training scripts from the 2006 MT Shared Task. We still tuned our model parameters on TRAIN and 767 \x0cBLEU over the Pharaoh, run with the monotone flag.13 Even though we are using a monotonic decoder, our best results are still sl</context>
</contexts>
<marker>Och, 2003</marker>
<rawString>Franz Josef Och. 2003. Minimum Error Rate Training in Statistical Machine Translation. In ACL 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ariadna Quattoni</author>
<author>Michael Collins</author>
<author>Trevor Darrell</author>
</authors>
<date>2004</date>
<contexts>
<context position="9783" citStr="Quattoni et al., 2004" startWordPosition="1632" endWordPosition="1635">4 \x06 \t \x03 \x17 \x12 \x03 \x11 \x02 \x18 \x01 \t \x12 \t \x15 \x03 \x04 \x02 \x19 \t \x01 \x03 \x12 \t \x03 \x14 \x12 \t \x15 \x03 \x04 \x03 \x01 \x02 \x10 \x11 \x12 \t \x01 \x02 \x03 \x01 \x04 \x01 \x02 \x10 \x11 \x12 \t Figure 1: Given the current prediction (a), there are two possible updates, local (b) and bold (c). Although the bold update (c) reaches the reference translation, a bad correspondence is used. The local update (b) does not reach the reference, but is more reasonable than (c). Discriminative training with hidden variables has been handled in this probabilistic framework (Quattoni et al., 2004; Koo and Collins, 2005), but we choose Equation 3 for efficiency. It turns out that using the Viterbi approximation (which we call bold updating) is not always the best strategy. To appreciate the difficulty, consider the example in Figure 1. Suppose we make the prediction (a) with the current set of parameters. There are often several acceptable output translations y, for example, (b) and (c). Since (c)s output matches the reference translation, should we update towards (c)? In this case, the answer is negative. The problem with (c) is that the correspondence h contains an incorrect alignmen</context>
</contexts>
<marker>Quattoni, Collins, Darrell, 2004</marker>
<rawString>Ariadna Quattoni, Michael Collins, and Trevor Darrell. 2004.</rawString>
</citation>
<citation valid="true">
<title>Conditional Random Fields for Object Recognition. In</title>
<date>2004</date>
<booktitle>NIPS</booktitle>
<contexts>
<context position="32034" citStr="(2004)" startWordPosition="5355" endWordPosition="5355">with a small handful of parameters. The second approach is to use reranking, in which a baseline classifier generates an n-best list of candidate translations, and a separate discriminative classifier chooses amongst them (Shen et al., 2004; Och et al., 2004). The major limitation of a reranking system is its dependence on the underlying baseline system, which bounds the potential improvement from discriminative training. In machine translation, this limitation is a real concern; it is common for all translations on moderately-sized n-best lists to be of poor quality. For instance, Och et al. (2004) reported that a 1000-best list was required to achieve performance gains from reranking. In contrast, the decoder in our system can use the feature weights learned in the previous iteration. Tillmann and Zhang (2005) present a discriminative approach based on local models. Their formulation explicitly decomposed the score of a translation into a sequence of local decisions, while our formulation allows global estimation. 9 Conclusion We have presented a novel end-to-end discriminative system for machine translation. We studied update strategies, an important issue in online discriminative tra</context>
</contexts>
<marker>2004</marker>
<rawString>Conditional Random Fields for Object Recognition. In NIPS 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stefan Riezler</author>
<author>John T Maxwell</author>
</authors>
<title>On Some Pitfalls in Automatic Evaluation and Significance Testing for MT.</title>
<date>2005</date>
<booktitle>In Workshop on Intrinsic and Extrinsic Evaluation Methods for MT and Summarization (MTSE).</booktitle>
<marker>Riezler, Maxwell, 2005</marker>
<rawString>Stefan Riezler and John T. Maxwell. 2005. On Some Pitfalls in Automatic Evaluation and Significance Testing for MT. In Workshop on Intrinsic and Extrinsic Evaluation Methods for MT and Summarization (MTSE).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Brian Roark</author>
<author>Murat Saraclar</author>
<author>Michael Collins</author>
<author>Mark Johnson</author>
</authors>
<title>Discriminative Language Modeling with Conditional Random Fields and the Perceptron Algorithm.</title>
<date>2004</date>
<contexts>
<context position="7305" citStr="Roark et al., 2004" startWordPosition="1167" endWordPosition="1170">clude the scores of various productions used in the tree. Given features and a corresponding set of parameters w, a standard classification rule f is to return the highest scoring output sentence y, maximizing over correspondences h: f(x; w) = argmax y,h w (x, y, h). (1) In the phrase-based model, computing the argmax exactly is intractable, so we approximate f with beam decoding. 2.2 Perceptron-based training To tune the parameters w of the model, we use the averaged perceptron algorithm (Collins, 2002) because of its efficiency and past success on various NLP tasks (Collins and Roark, 2004; Roark et al., 2004). In principle, w could have been tuned by maximizing conditional probability or maximizing margin. However, these two options require either marginalization or numerical optimization, neither of which is tractable over the space of output sentences y and correspondences h. In contrast, the perceptron algorithm requires only a decoder that computes f(x; w). Recall the traditional perceptron update rule on an example (xi, yi) is w w + (xi, yt) (xi, yp), (2) where yt = yi is the target output and yp = f(xi; w) = argmaxy w (xi, y) is the prediction using the current parameters w. We adapt this up</context>
<context position="22665" citStr="Roark et al., 2004" startWordPosition="3802" endWordPosition="3805"> features The blanket features provide a rough guide for translation, but they are far too coarse to fix specific mistakes. We therefore add lexical features (LEX) to allow for more fine-grained control. These features come in two varieties. Lexical phrase features indicate the presence of a specific translation phrase, such as (y a-t-il, are there), and lexical language model features indicate the presence of a specific output n-gram, such as of the. Lexical language model features have been exploited successfully in discriminative language modeling to improve speech recognition performance (Roark et al., 2004). We confirm the utility of the two kinds of lexical features: BLANKET+LEX achieves a BLEU score of 35.0, an improvement of 1.6 over BLANKET. To understand the effect of adding lexical features, consider the ten with highest and lowest weights after training: 64 any comments ? -55 (des, of) 63 (y a-t-il, are there) -52 (y a-t-il, are there any) 62 there any comments -42 there any of 57 any comments -39 of comments 46 (des, any) -38 of comments ? These features can in fact be traced back to the following example: Input y a-t-il des observations ? B are there any of comments ? B+L are there any </context>
</contexts>
<marker>Roark, Saraclar, Collins, Johnson, 2004</marker>
<rawString>Brian Roark, Murat Saraclar, Michael Collins, and Mark Johnson. 2004. Discriminative Language Modeling with Conditional Random Fields and the Perceptron Algorithm.</rawString>
</citation>
<citation valid="true">
<date>2004</date>
<booktitle>In ACL</booktitle>
<contexts>
<context position="32034" citStr="(2004)" startWordPosition="5355" endWordPosition="5355">with a small handful of parameters. The second approach is to use reranking, in which a baseline classifier generates an n-best list of candidate translations, and a separate discriminative classifier chooses amongst them (Shen et al., 2004; Och et al., 2004). The major limitation of a reranking system is its dependence on the underlying baseline system, which bounds the potential improvement from discriminative training. In machine translation, this limitation is a real concern; it is common for all translations on moderately-sized n-best lists to be of poor quality. For instance, Och et al. (2004) reported that a 1000-best list was required to achieve performance gains from reranking. In contrast, the decoder in our system can use the feature weights learned in the previous iteration. Tillmann and Zhang (2005) present a discriminative approach based on local models. Their formulation explicitly decomposed the score of a translation into a sequence of local decisions, while our formulation allows global estimation. 9 Conclusion We have presented a novel end-to-end discriminative system for machine translation. We studied update strategies, an important issue in online discriminative tra</context>
</contexts>
<marker>2004</marker>
<rawString>In ACL 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Helmut Schmid</author>
</authors>
<title>Probabilistic Part-of-Speech Tagging Using Decision Trees.</title>
<date>1994</date>
<booktitle>In International Conference on New Methods in Language Processing.</booktitle>
<contexts>
<context position="25465" citStr="Schmid, 1994" startWordPosition="4284" endWordPosition="4285">appropriately with suitable non-literal translations. This point highlights the strength of discriminative training: weights are jointly tuned to account for the intricate interactions between overlapping phrases, which is something not achievable by estimating the weights directly from surface statistics. 6.3 Part-of-speech features While lexical features are useful for eliminating specific errors, they have limited ability to generalize to related phrases. This suggests the use of similar features which are abstracted to the POS level.7 In our experiments, we used the TreeTagger POS tagger (Schmid, 1994), which ships pretrained on several languages, to map each word to its majority POS tag. We could also relatively easily base our features on context-dependent POS tags: the entire input sentence is available before decoding begins, and the output sentence is decoded left-to-right and could be tagged incrementally. Where we had lexical phrase features, such as (la realisation du droit, the right), we now also have their POS abstractions, for instance (DT NN IN NN, DT NN). This phrase pair is undesirable, not because of particular lexical facts about la realisation, but because dropping a nomin</context>
</contexts>
<marker>Schmid, 1994</marker>
<rawString>Helmut Schmid. 1994. Probabilistic Part-of-Speech Tagging Using Decision Trees. In International Conference on New Methods in Language Processing.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Libin Shen</author>
<author>Anoop Sarkar</author>
<author>Franz Josef Och</author>
</authors>
<title>Discriminative Reranking for Machine Translation. In HLTNAACL</title>
<date>2004</date>
<contexts>
<context position="2242" citStr="Shen et al., 2004" startWordPosition="335" endWordPosition="338">e to easily encode domain knowledge in the form of features. Moreover, parameters are tuned to directly minimize error rather than to maximize joint likelihood, which may not correspond well to the task objective. In this paper, we present an end-to-end discriminative approach to machine translation. The proposed system is phrase-based, as in Koehn et al. (2003), but uses an online perceptron training scheme to learn model parameters. Unlike minimum error rate training (Och, 2003), our system is able to exploit large numbers of specific features in the same manner as static reranking systems (Shen et al., 2004; Och et al., 2004). However, unlike static rerankers, our system does not rely on a baseline translation system. Instead, it updates based on its own n-best lists. As parameter estimates improve, the system produces better nbest lists, which can in turn enable better updates in future training iterations. In this paper, we focus on two aspects of the problem of discriminative translation: the inherent difficulty of learning from reference translations, and the challenge of engineering effective features for this task. Discriminative learning from reference translations is inherently problemat</context>
<context position="31668" citStr="Shen et al., 2004" startWordPosition="5292" endWordPosition="5295">sion of Pharaoh that permits arbitrary distortion. 8 Related work In machine translation, most discriminative approaches currently fall into two general categories. The first approach is to reuse the components of a generative model, but tune their relative weights in a discriminative fashion (Och and Ney, 2002; Och, 2003; Chiang, 2005). This approach only works in practice with a small handful of parameters. The second approach is to use reranking, in which a baseline classifier generates an n-best list of candidate translations, and a separate discriminative classifier chooses amongst them (Shen et al., 2004; Och et al., 2004). The major limitation of a reranking system is its dependence on the underlying baseline system, which bounds the potential improvement from discriminative training. In machine translation, this limitation is a real concern; it is common for all translations on moderately-sized n-best lists to be of poor quality. For instance, Och et al. (2004) reported that a 1000-best list was required to achieve performance gains from reranking. In contrast, the decoder in our system can use the feature weights learned in the previous iteration. Tillmann and Zhang (2005) present a discri</context>
</contexts>
<marker>Shen, Sarkar, Och, 2004</marker>
<rawString>Libin Shen, Anoop Sarkar, and Franz Josef Och. 2004. Discriminative Reranking for Machine Translation. In HLTNAACL 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andreas Stolcke</author>
</authors>
<title>SRILM An Extensible Language Modeling Toolkit.</title>
<date>2002</date>
<booktitle>In ICSLP</booktitle>
<contexts>
<context position="12288" citStr="Stolcke, 2002" startWordPosition="2065" endWordPosition="2066"> performance of the system as we developed it. Note that the DEV set was not used to tune any parameters; tuning was done exclusively on TRAIN. At the end we ran our models once on TEST to get final numbers.2 4 Models Our experiments used phrase-based models (Koehn et al., 2003), which require a translation table and language model for decoding and feature computation. To facilitate comparison with previous work, we created the translation tables using the same techniques as Koehn et al. (2003).3 The language model was a Kneser-Ney interpolated trigram model generated using the SRILM toolkit (Stolcke, 2002). We built our own phrase-based beam decoder that can handle arbitrary features.4 The contributions of features are incrementally added into the score as decoding 2 We also experimented with several combinations of jackknifing to prevent overfitting, in which we selected features on TRAIN-OLD (19961998 Europarl corpus) and tuned the parameters on TRAIN, or vice-versa. However, it turned out that using TRAIN-OLD was suboptimal since that data is less relevant to DEV. Another alternative is to combine TRAINOLD and TRAIN into one dual-purpose dataset. The differences between this and our current </context>
</contexts>
<marker>Stolcke, 2002</marker>
<rawString>Andreas Stolcke. 2002. SRILM An Extensible Language Modeling Toolkit. In ICSLP 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Christoph Tillmann</author>
<author>Tong Zhang</author>
</authors>
<title>A Localized Prediction Model for Statistical Machine Translation. In</title>
<date>2005</date>
<booktitle>ACL</booktitle>
<contexts>
<context position="4663" citStr="Tillmann and Zhang, 2005" startWordPosition="716" endWordPosition="719">m each. We then present a novel way to parameterize and introduce learning into the initial phrase extraction process. In particular, we introduce alignment constellation features, which allow us to weight phrases based on the word alignment pattern that led to their extraction. This kind of 761 \x0cfeature provides a potential way to initially extract phrases more aggressively and then later downweight undesirable patterns, essentially learning a weighted extraction heuristic. Finally, we use POS features to parameterize a distortion model in a limited distortion decoder (Zens and Ney, 2004; Tillmann and Zhang, 2005). We show that overall, BLEU score increases from 28.4 to 29.6 on French-English. 2 Approach 2.1 Translation as structured classification Machine translation can be seen as a structured classification task, in which the goal is to learn a mapping from an input (French) sentence x to an output (English) sentence y. Given this setup, discriminative methods allow us to define a broad class of features that operate on (x, y). For example, some features would measure the fluency of y and others would measure the faithfulness of y as a translation of x. However, the translation task in this framewor</context>
<context position="32251" citStr="Tillmann and Zhang (2005)" startWordPosition="5388" endWordPosition="5391">er chooses amongst them (Shen et al., 2004; Och et al., 2004). The major limitation of a reranking system is its dependence on the underlying baseline system, which bounds the potential improvement from discriminative training. In machine translation, this limitation is a real concern; it is common for all translations on moderately-sized n-best lists to be of poor quality. For instance, Och et al. (2004) reported that a 1000-best list was required to achieve performance gains from reranking. In contrast, the decoder in our system can use the feature weights learned in the previous iteration. Tillmann and Zhang (2005) present a discriminative approach based on local models. Their formulation explicitly decomposed the score of a translation into a sequence of local decisions, while our formulation allows global estimation. 9 Conclusion We have presented a novel end-to-end discriminative system for machine translation. We studied update strategies, an important issue in online discriminative training for MT, and conclude that making many smaller (conservative) updates is better than making few large (aggressive) updates. We also investigated the effect of adding many expressive features, which yielded a 0.8 </context>
</contexts>
<marker>Tillmann, Zhang, 2005</marker>
<rawString>Christoph Tillmann and Tong Zhang. 2005. A Localized Prediction Model for Statistical Machine Translation. In ACL 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richard Zens</author>
<author>Hermann Ney</author>
</authors>
<title>Improvements in Statistical Phrase-Based Translation.</title>
<date>2004</date>
<booktitle>In HLT-NAACL</booktitle>
<contexts>
<context position="4636" citStr="Zens and Ney, 2004" startWordPosition="712" endWordPosition="715">s, showing gains from each. We then present a novel way to parameterize and introduce learning into the initial phrase extraction process. In particular, we introduce alignment constellation features, which allow us to weight phrases based on the word alignment pattern that led to their extraction. This kind of 761 \x0cfeature provides a potential way to initially extract phrases more aggressively and then later downweight undesirable patterns, essentially learning a weighted extraction heuristic. Finally, we use POS features to parameterize a distortion model in a limited distortion decoder (Zens and Ney, 2004; Tillmann and Zhang, 2005). We show that overall, BLEU score increases from 28.4 to 29.6 on French-English. 2 Approach 2.1 Translation as structured classification Machine translation can be seen as a structured classification task, in which the goal is to learn a mapping from an input (French) sentence x to an output (English) sentence y. Given this setup, discriminative methods allow us to define a broad class of features that operate on (x, y). For example, some features would measure the fluency of y and others would measure the faithfulness of y as a translation of x. However, the transl</context>
<context position="13578" citStr="Zens and Ney, 2004" startWordPosition="2272" endWordPosition="2275">ct a word alignment in each direction and a growth heuristic to combine them. We extracted all the substrings that are closed under this high-quality word alignment and computed surface statistics from cooccurrences counts. 4 In our experiments, we used a beam size of 10, which we found to be only slightly worse than using a beam of 100. 763 \x0cproceeds. We experimented with two levels of distortion: monotonic, where the phrasal alignment is monotonic (but word reordering is still possible within a phrase) and limited distortion, where only adjacent phrases are allowed to exchange positions (Zens and Ney, 2004). In the future, we plan to explore our discriminative framework on a full distortion model (Koehn et al., 2003) or even a hierarchical model (Chiang, 2005). Throughout the following experiments, we trained the perceptron algorithm for 10 iterations. The weights were initialized to 1 on the translation table, 1 on the language model (the blanket features in Section 6), and 0 elsewhere. The next two sections give experiments on the two key components of a discriminative machine translation system: choosing the proper update strategy (Section 5) and including powerful features (Section 6). 5 Upd</context>
</contexts>
<marker>Zens, Ney, 2004</marker>
<rawString>Richard Zens and Hermann Ney. 2004. Improvements in Statistical Phrase-Based Translation. In HLT-NAACL 2004.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>