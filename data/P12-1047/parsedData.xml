<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<bodyText confidence="0.8779145">
b&apos;Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics, pages 449458,
Jeju, Republic of Korea, 8-14 July 2012. c
</bodyText>
<sectionHeader confidence="0.599175" genericHeader="abstract">
2012 Association for Computational Linguistics
</sectionHeader>
<title confidence="0.500573">
String Re-writing Kernel
</title>
<author confidence="0.493634">
Fan Bu1, Hang Li2 and Xiaoyan Zhu3
</author>
<footnote confidence="0.968566428571428">
1,3State Key Laboratory of Intelligent Technology and Systems
1,3Tsinghua National Laboratory for Information Sci. and Tech.
1,3Department of Computer Sci. and Tech., Tsinghua University
2Microsoft Research Asia, No. 5 Danling Street, Beijing 100080,China
1bufan0000@gmail.com
2hangli@microsoft.com
3zxy-dcs@tsinghua.edu.cn
</footnote>
<sectionHeader confidence="0.964144" genericHeader="keywords">
Abstract
</sectionHeader>
<bodyText confidence="0.990348578947368">
Learning for sentence re-writing is a funda-
mental task in natural language processing and
information retrieval. In this paper, we pro-
pose a new class of kernel functions, referred
to as string re-writing kernel, to address the
problem. A string re-writing kernel measures
the similarity between two pairs of strings,
each pair representing re-writing of a string.
It can capture the lexical and structural sim-
ilarity between two pairs of sentences with-
out the need of constructing syntactic trees.
We further propose an instance of string re-
writing kernel which can be computed effi-
ciently. Experimental results on benchmark
datasets show that our method can achieve bet-
ter results than state-of-the-art methods on two
sentence re-writing learning tasks: paraphrase
identification and recognizing textual entail-
ment.
</bodyText>
<sectionHeader confidence="0.997105" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.951092571428572">
Learning for sentence re-writing is a fundamental
task in natural language processing and information
retrieval, which includes paraphrasing, textual en-
tailment and transformation between query and doc-
ument title in search.
The key question here is how to represent the re-
writing of sentences. In previous research on sen-
tence re-writing learning such as paraphrase identifi-
cation and recognizing textual entailment, most rep-
resentations are based on the lexicons (Zhang and
Patrick, 2005; Lintean and Rus, 2011; de Marneffe
et al., 2006) or the syntactic trees (Das and Smith,
wrote . Shakespeare wrote Hamlet.
* was written by . Hamlet was written by Shakespeare.
</bodyText>
<figure confidence="0.995799666666667">
(B)
*
*
*
*
(A)
</figure>
<figureCaption confidence="0.999971">
Figure 1: Example of re-writing. (A) is a re-writing rule
</figureCaption>
<bodyText confidence="0.997838857142857">
and (B) is a re-writing of sentence.
2009; Heilman and Smith, 2010) of the sentence
pairs.
In (Lin and Pantel, 2001; Barzilay and Lee, 2003),
re-writing rules serve as underlying representations
for paraphrase generation/discovery. Motivated by
the work, we represent re-writing of sentences by
all possible re-writing rules that can be applied into
it. For example, in Fig. 1, (A) is one re-writing rule
that can be applied into the sentence re-writing (B).
Specifically, we propose a new class of kernel func-
tions (Scholkopf and Smola, 2002), called string re-
writing kernel (SRK), which defines the similarity
between two re-writings (pairs) of strings as the in-
ner product between them in the feature space in-
duced by all the re-writing rules. SRK is different
from existing kernels in that it is for re-writing and
defined on two pairs of strings. SRK can capture the
lexical and structural similarity between re-writings
of sentences and does not need to parse the sentences
and create the syntactic trees of them.
One challenge for using SRK lies in the high com-
putational cost of straightforwardly computing the
kernel, because it involves two re-writings of strings
(i.e., four strings) and a large number of re-writing
rules. We are able to develop an instance of SRK,
referred to as kb-SRK, which directly computes the
number of common rewriting rules without explic-
</bodyText>
<page confidence="0.997736">
449
</page>
<bodyText confidence="0.9993621">
\x0citly calculating the inner product between feature
vectors, and thus drastically reduce the time com-
plexity.
Experimental results on benchmark datasets show
that SRK achieves better results than the state-of-
the-art methods in paraphrase identification and rec-
ognizing textual entailment. Note that SRK is very
flexible to the formulations of sentences. For ex-
ample, informally written sentences such as long
queries in search can also be effectively handled.
</bodyText>
<sectionHeader confidence="0.999637" genericHeader="related work">
2 Related Work
</sectionHeader>
<bodyText confidence="0.99860487755102">
The string kernel function, first proposed by Lodhi
et al. (2002), measures the similarity between two
strings by their shared substrings. Leslie et al.
(2002) proposed the k-spectrum kernel which repre-
sents strings by their contiguous substrings of length
k. Leslie et al. (2004) further proposed a number of
string kernels including the wildcard kernel to fa-
cilitate inexact matching between the strings. The
string kernels defined on two pairs of objects (in-
cluding strings) were also developed, which decom-
pose the similarity into product of similarities be-
tween individual objects using tensor product (Basil-
ico and Hofmann, 2004; Ben-Hur and Noble, 2005)
or Cartesian product (Kashima et al., 2009).
The task of paraphrasing usually consists of para-
phrase pattern generation and paraphrase identifica-
tion. Paraphrase pattern generation is to automat-
ically extract semantically equivalent patterns (Lin
and Pantel, 2001; Bhagat and Ravichandran, 2008)
or sentences (Barzilay and Lee, 2003). Paraphrase
identification is to identify whether two given sen-
tences are a paraphrase of each other. The meth-
ods proposed so far formalized the problem as clas-
sification and used various types of features such
as bag-of-words feature, edit distance (Zhang and
Patrick, 2005), dissimilarity kernel (Lintean and
Rus, 2011) predicate-argument structure (Qiu et al.,
2006), and tree edit model (which is based on a tree
kernel) (Heilman and Smith, 2010) in the classifica-
tion task. Among the most successful methods, Wan
et al. (2006) enriched the feature set by the BLEU
metric and dependency relations. Das and Smith
(2009) used the quasi-synchronous grammar formal-
ism to incorporate features from WordNet, named
entity recognizer, POS tagger, and dependency la-
bels from aligned trees.
The task of recognizing textual entailment is to
decide whether the hypothesis sentence can be en-
tailed by the premise sentence (Giampiccolo et al.,
2007). In recognizing textual entailment, de Marn-
effe et al. (2006) classified sentences pairs on the
basis of word alignments. MacCartney and Man-
ning (2008) used an inference procedure based on
natural logic and combined it with the methods by
de Marneffe et al. (2006). Harmeling (2007) and
Heilman and Smith (2010) classified sequence pairs
based on transformation on syntactic trees. Zanzotto
et al. (2007) used a kernel method on syntactic tree
pairs (Moschitti and Zanzotto, 2007).
</bodyText>
<sectionHeader confidence="0.941968" genericHeader="method">
3 Kernel Approach to Sentence
</sectionHeader>
<subsectionHeader confidence="0.709355">
Re-Writing Learning
</subsectionHeader>
<bodyText confidence="0.999562666666667">
We formalize sentence re-writing learning as a ker-
nel method. Following the literature of string kernel,
we use the terms string and character instead of
sentence and word.
Suppose that we are given training data consisting
of re-writings of strings and their responses
</bodyText>
<equation confidence="0.9665035">
((s1,t1),y1),...,((sn,tn),yn) (
)Y
</equation>
<bodyText confidence="0.995905">
where denotes the character set, =
</bodyText>
<equation confidence="0.82234">
S
i=0 i de-
</equation>
<bodyText confidence="0.984110666666667">
notes the string set, which is the Kleene closure of
set , Y denotes the set of responses, and n is the
number of instances. (si,ti) is a re-writing consist-
ing of the source string si and the target string ti.
yi is the response which can be a category, ordinal
number, or real number. In this paper, for simplic-
ity we assume that Y = {1} (e.g. paraphrase/non-
paraphrase). Given a new string re-writing (s,t)
, our goal is to predict its response y. That is,
the training data consists of binary classes of string
re-writings, and the prediction is made for the new
re-writing based on learning from the training data.
We take the kernel approach to address the learn-
ing task. The kernel on re-writings of strings is de-
fined as
</bodyText>
<equation confidence="0.990538">
K : (
)(
) R
satisfying for all (si,ti), (sj,tj) ,
K((si,ti),(sj,tj)) = h(si,ti),(sj,tj)i
</equation>
<bodyText confidence="0.999633">
where maps each re-writing (pair) of strings into
a high dimensional Hilbert space H , referred to as
</bodyText>
<page confidence="0.987668">
450
</page>
<bodyText confidence="0.97160725">
\x0cfeature space. By the representer theorem (Kimel-
dorf and Wahba, 1971; Scholkopf and Smola, 2002),
it can be shown that the response y of a new string
re-writing (s,t) can always be represented as
</bodyText>
<equation confidence="0.9922015">
y = sign(
n
i=1
iyiK((si,ti),(s,t)))
</equation>
<bodyText confidence="0.985352555555556">
where i 0,(i = 1, ,n) are parameters. That is,
it is determined by a linear combination of the sim-
ilarities between the new instance and the instances
in training set. It is also known that by employing a
learning model such as SVM (Vapnik, 2000), such a
linear combination can be automatically learned by
solving a quadratic optimization problem. The ques-
tion then becomes how to design the kernel function
for the task.
</bodyText>
<sectionHeader confidence="0.93246" genericHeader="method">
4 String Re-writing Kernel
</sectionHeader>
<bodyText confidence="0.973286555555556">
Let be the set of characters and be the set of
strings. Let wildcard domain D be the set of
strings which can be replaced by wildcards.
The string re-writing kernel measures the similar-
ity between two string re-writings through the re-
writing rules that can be applied into them. For-
mally, given re-writing rule set R and wildcard do-
main D, the string re-writing kernel (SRK) is defined
as
</bodyText>
<equation confidence="0.999721333333333">
K((s1,t1),(s2,t2)) = h(s1,t1),(s2,t2)i (1)
where (s,t) = (r(s,t))rR and
r(s,t) = ni
</equation>
<bodyText confidence="0.881339514285714">
(2)
where n is the number of contiguous substring pairs
of (s,t) that re-writing rule r matches, i is the num-
ber of wildcards in r, and (0,1] is a factor pun-
ishing each occurrence of wildcard.
A re-writing rule is defined as a triple r =
(s,t,) where s,t ( {}) denote source
and target string patterns and ind(s)ind(t)
denotes the alignments between the wildcards in the
two string patterns. Here ind() denotes the set of
indexes of wildcards in .
We say that a re-writing rule (s,t,) matches a
string pair (s,t), if and only if string patterns s and
t can be changed into s and t respectively by sub-
stituting each wildcard in the string patterns with an
element in the strings, where the elements are de-
fined in the wildcard domain D and the wildcards
s[i] and t[j] are substituted by the same elements,
when there is an alignment (i, j) .
For example, the re-writing rule in Fig. 1 (A)
can be formally written as r = (s,t,) where
s = (,wrote,), t = (,was,written,by,) and
= {(1,5),(3,1)}. It matches with the string pair in
Fig. 1 (B).
String re-writing kernel is a class of kernels which
depends on re-writing rule set R and wildcard do-
main D. Here we provide some examples. Obvi-
ously, the effectiveness and efficiency of SRK de-
pend on the choice of R and D.
Example 1. We define the pairwise k-spectrum ker-
nel (ps-SRK) Kps
k as the re-writing rule kernel un-
der R = {(s,t,)|s,t k, = /
0} and any
D. It can be shown that Kps
</bodyText>
<equation confidence="0.9941462">
k ((s1,t1),(s2,t2)) =
Kspec
k (s1,s2)Kspec
k (t1,t2) where Kspec
k (x,y) is equiv-
</equation>
<bodyText confidence="0.599006">
alent to the k-spectrum kernel proposed by Leslie et
al. (2002).
Example 2. The pairwise k-wildcard kernel (pw-
</bodyText>
<equation confidence="0.744377888888889">
SRK) Kpw
k is defined as the re-writing rule kernel
under R = {(s,t,)|s,t ({})k, = /
0} and
D = . It can be shown that Kpw
k ((s1,t1),(s2,t2)) =
Kwc
(k,k)(s1,s2)Kwc
(k,k)(t1,t2) where Kwc
</equation>
<bodyText confidence="0.937390428571429">
(k,k)(x,y) is a spe-
cial case (m=k) of the (k,m)-wildcard kernel pro-
posed by Leslie et al. (2004).
Both kernels shown above are represented as the
product of two kernels defined separately on strings
s1,s2 and t1,t2, and that is to say that they do not
consider the alignment relations between the strings.
</bodyText>
<sectionHeader confidence="0.730841" genericHeader="method">
5 K-gram Bijective String Re-writing
Kernel
</sectionHeader>
<bodyText confidence="0.9974895">
Next we propose another instance of string re-
writing kernel, called the k-gram bijective string re-
writing kernel (kb-SRK). As will be seen, kb-SRK
can be computed efficiently, although it is defined
on two pairs of strings and is not decomposed (note
that ps-SRK and pw-SRK are decomposed).
</bodyText>
<subsectionHeader confidence="0.980197">
5.1 Definition
</subsectionHeader>
<bodyText confidence="0.9990775">
The kb-SRK has the following properties: (1) A
wildcard can only substitute a single character, de-
noted as ?. (2) The two string patterns in a re-
writing rule are of length k. (3) The alignment
relation in a re-writing rule is bijective, i.e., there
is a one-to-one mapping between the wildcards in
</bodyText>
<page confidence="0.995215">
451
</page>
<bodyText confidence="0.811179555555556">
\x0cthe string patterns. Formally, the k-gram bijective
string re-writing kernel Kk is defined as a string
re-writing kernel under the re-writing rule set R =
{(s,t,)|s,t ({?})k, is bijective} and the
wildcard domain D = .
Since each re-writing rule contains two string pat-
terns of length k and each wildcard can only substi-
tute one character, a re-writing rule can only match
k-gram pairs in (s,t). We can rewrite Eq. (2) as
</bodyText>
<equation confidence="0.9155345">
r(s,t) =
sk-grams(s)
t k-grams(t)
r(s,t) (3)
where r(s,t) = i if r (with i wildcards) matches
(s,t), otherwise r(s,t) = 0.
</equation>
<bodyText confidence="0.708417">
For ease of computation, we re-write kb-SRK as
</bodyText>
<equation confidence="0.9989375">
Kk((s1,t1),(s2,t2))
=
s1
k-grams(s1)
t1
k-grams(t1)
s2
k-grams(s2)
t2
k-grams(t2)
Kk((s1 ,t1 ),(s2 ,t2 ))
(4)
where
Kk =
rR
r(s1 ,t1 )r(s2 ,t2 ) (5)
</equation>
<subsectionHeader confidence="0.988506">
5.2 Algorithm for Computing Kernel
</subsectionHeader>
<bodyText confidence="0.974728583333333">
A straightforward computation of kb-SRK would
be intractable. The computation of Kk in Eq. (4)
needs computations of Kk conducted O((n k +
1)4) times, where n denotes the maximum length
of strings. Furthermore, the computation of Kk in
Eq. (5) needs to perform matching of all the re-
writing rules with the two k-gram pairs (s1 , t1 ),
(s2 , t2 ), which has time complexity O(k!).
In this section, we will introduce an efficient algo-
rithm, which can compute Kk and Kk with the time
complexities of O(k) and O(kn2), respectively. The
latter is verified empirically.
</bodyText>
<subsubsectionHeader confidence="0.518298">
5.2.1 Transformation of Problem
</subsubsectionHeader>
<bodyText confidence="0.999436333333333">
For ease of manipulation, our method transforms
the computation of kernel on k-grams into the com-
putation on a new data structure called lists of dou-
bles. We first explain how to make the transforma-
tion.
Suppose that 1,2 k are k-grams, we use
1[i] and 2[i] to represent the i-th characters of
them. We call a pair of characters a double. Thus
denotes the set of doubles and D
</bodyText>
<equation confidence="0.98731775">
s ,D
t (
s1
= abbccbb ; s2
= abcccdd;
t1
= cbcbbcb ; t2
= cbccdcd;
</equation>
<figureCaption confidence="0.972011">
Figure 2: Example of two k-gram pairs.
</figureCaption>
<equation confidence="0.7552835">
s
D
= (a, a), (b, b), (b, c), (c, c), (c, c), (b, d), (b, d)
t
D
= (c, c), (b, b), (c, c), (b, c), (b, d), (c, c), (b, d)
</equation>
<figureCaption confidence="0.998698">
Figure 3: Example of the pair of double lists combined
</figureCaption>
<bodyText confidence="0.9801115">
from the two k-gram pairs in Fig. 2. Non-identical dou-
bles are in bold.
)k denote lists of doubles. The following operation
combines two k-grams into a list of doubles.
</bodyText>
<equation confidence="0.699643">
1 2 = ((1[1],2[1]), ,(1[k],2[k])).
</equation>
<bodyText confidence="0.994385">
We denotes 1 2[i] as the i-th element of the
list. Fig. 3 shows example lists of doubles combined
from k-grams.
We introduce the set of identical doubles I =
{(c,c)|c } and the set of non-identical doubles
</bodyText>
<equation confidence="0.955072">
N = {(c,c0)|c,c0 and c 6= c0}. Obviously, I
S
N =
and I
T
N = /
0.
</equation>
<bodyText confidence="0.99201">
We define the set of re-writing rules for double
</bodyText>
<equation confidence="0.94514175">
lists RD = {rD = (D
s ,D
t ,)|D
s ,D
t (I{?})k,
is a bijective alignment} where D
s and D
t are lists
</equation>
<bodyText confidence="0.917381">
of identical doubles including wildcards and with
length k. We say rule rD matches a pair of double
</bodyText>
<equation confidence="0.927979571428572">
lists (D
s ,D
t ) iff. D
s ,D
t can be changed into D
s
and D
</equation>
<bodyText confidence="0.962236090909091">
t by substituting each wildcard pair to a dou-
ble in , and the double substituting the wild-
card pair D
s [i] and D
t [j] must be an identical dou-
ble when there is an alignment (i, j) . The rule
set defined here and the rule set in Sec. 4 only differ
on the elements where re-writing occurs. Fig. 4 (B)
shows an example of re-writing rule for double lists.
The pair of double lists in Fig. 3 can match with the
re-writing rule.
</bodyText>
<subsubsectionHeader confidence="0.993337">
5.2.2 Computing Kk
</subsubsectionHeader>
<bodyText confidence="0.998590428571429">
We consider how to compute Kk by extending the
computation from k-grams to double lists.
The following lemma shows that computing the
weighted sum of re-writing rules matching k-gram
pairs (s1 ,t1 ) and (s2 ,t2 ) is equivalent to com-
puting the weighted sum of re-writing rules for dou-
ble lists matching (s1 s2 ,t1 t2 ).
</bodyText>
<page confidence="0.968319">
452
</page>
<figure confidence="0.958983">
\x0ca b *1 c a b ? c c ? ? (a,a) (b,b) ? (c,c) (c,c) ? ?
c b c ? ? c ? (c,c) (b,b) (c,c) ? ? (c,c) ?
(A) (B)
</figure>
<figureCaption confidence="0.997233">
Figure 4: For re-writing rule (A) matching both k-gram
</figureCaption>
<bodyText confidence="0.916190666666667">
pairs shown in Fig. 2, there is a corresponding re-writing
rule for double lists (B) matching the pair of double lists
shown in Fig. 3.
</bodyText>
<equation confidence="0.788562666666667">
#(s
D
) = {(a, a): 1, (b, b): 1, (b, c): 1, (b, d): 2, (c, c): 2}
#(t
D
) = {(a, a): 0, (b, b): 1, (b, c): 1, (b, d): 2, (c, c): 3}
</equation>
<figureCaption confidence="0.999081">
Figure 5: Example of #() for the two double lists
</figureCaption>
<bodyText confidence="0.726716">
shown in Fig. 3. Doubles not appearing in both D
</bodyText>
<equation confidence="0.323748">
s and
D
t are not shown.
</equation>
<construct confidence="0.845548">
Lemma 1. For any two k-gram pairs (s1 ,t1 ) and
</construct>
<bodyText confidence="0.938936125">
(s2 ,t2 ), there exists a one-to-one mapping from
the set of re-writing rules matching them to the set of
re-writing rules matching the corresponding double
lists (s1 s2 ,t1 t2 ).
The re-writing rule in Fig. 4 (A) matches the k-
gram pairs in Fig. 2. Equivalently, the re-writing
rule for double lists in Fig. 4 (B) matches the pair
of double lists in Fig. 3. By lemma 1 and Eq. 5, we
</bodyText>
<equation confidence="0.975872461538462">
have
Kk =
rDRD
rD (s1 s2 ,t1 t2 ) (6)
where rD (D
s ,D
t ) = 2i if the rewriting rule for
double lists rD with i wildcards matches (D
s ,D
t ),
otherwise rD (D
s ,D
t ) = 0. To get Kk, we just need
</equation>
<bodyText confidence="0.984700090909091">
to compute the weighted sum of re-writing rules for
double lists matching (s1 s2 ,t1 t2 ). Thus,
we can work on the combined pair of double lists
instead of two pairs of k-grams.
Instead of enumerating all possible re-writing
rules and checking whether they can match the given
pair of double lists, we only calculate the number of
possibilities of generating from the pair of double
lists to the re-writing rules matching it, which can be
carried out efficiently. We say that a re-writing rule
of double lists can be generated from a pair of double
</bodyText>
<table confidence="0.5470130625">
lists (D
s , D
t ), if they match with each other. From
the definition of RD, in each generation, the identi-
cal doubles in D
s and D
t can be either or not sub-
stituted by an aligned wildcard pair in the re-writing
Algorithm 1: Computing Kk
Input: k-gram pair (s1 ,t1 ) and (s2 ,t2 )
Output: Kk((s1 ,t1 ),(s2 ,t2 ))
1 Set (D
s ,D
t ) = (s1 s2 ,t1 t2 ) ;
2 Compute #(D
s ) and #(D
</table>
<equation confidence="0.9727334">
t );
3 result=1;
4 for each e satisfies
#e(D
s )+#e(D
t ) 6= 0 do
5 ge = 0, ne = min{#e(D
s ),#e(D
t )} ;
6 for 0 i ne do
7 ge = ge +a
(e)
i 2i;
8 result = result g;
9 return result;
</equation>
<bodyText confidence="0.54551">
rule, and all the non-identical doubles in D
</bodyText>
<equation confidence="0.9050985">
s and D
t
</equation>
<bodyText confidence="0.984063">
must be substituted by aligned wildcard pairs. From
this observation and Eq. 6, Kk only depends on the
number of times each double occurs in the double
lists.
Let e be a double. We denote #e(D) as the num-
ber of times e occurs in the list of doubles D. Also,
for a set of doubles S , we denote #S(D) as
a vector in which each element represents #e(D) of
each double e S. We can find a function g such
</bodyText>
<equation confidence="0.81747">
that
Kk = g(#(s1 s2 ),#(t1 t2 )) (7)
</equation>
<bodyText confidence="0.9925174">
Alg. 1 shows how to compute Kk. #(.) is com-
puted from the two pairs of k-grams in line 1-2. The
final score is made through the iterative calculation
on the two lists (lines 4-8).
The key of Alg. 1 is the calculation of ge based on
</bodyText>
<listItem confidence="0.531491461538461">
a
(e)
i (line 7). Here we use a
(e)
i to denote the number
of possibilities for which i pairs of aligned wildcards
can be generated from e in both D
s and D
t . a
(e)
i can
be computed as follows.
(1) If e N and #e(D
</listItem>
<equation confidence="0.99602225">
s ) 6= #e(D
t ), then a
(e)
i = 0
</equation>
<bodyText confidence="0.601604">
for any i.
</bodyText>
<listItem confidence="0.804446">
(2) If e N and #e(D
</listItem>
<equation confidence="0.949459411764706">
s ) = #e(D
t ) = j, then a
(e)
j =
j! and a
(e)
i = 0 for any i 6= j.
(3) If e I, then a
(e)
i = #e(D
s )
i
\x01 #e(D
t )
i
\x01
i!.
</equation>
<bodyText confidence="0.9952305">
We next explain the rationale behind the above
computations. In (1), since #e(D
</bodyText>
<equation confidence="0.803965">
s ) 6= #e(D
t ), it is
</equation>
<bodyText confidence="0.979227">
impossible to generate a re-writing rule in which all
</bodyText>
<page confidence="0.996756">
453
</page>
<bodyText confidence="0.9740095">
\x0cthe occurrences of non-identical double e are substi-
tuted by pairs of aligned wildcards. In (2), j pairs of
aligned wildcards can be generated from all the oc-
currences of non-identical double e in both D
</bodyText>
<equation confidence="0.552149333333333">
s and
D
t . The number of combinations thus is j!. In (3),
</equation>
<bodyText confidence="0.955413">
a pair of aligned wildcards can either be generated
or not from a pair of identical doubles in D
</bodyText>
<equation confidence="0.82960375">
s and
D
t . We can select i occurrences of identical double
e from D
</equation>
<bodyText confidence="0.95229775">
s , i occurrences from D
t , and generate all
possible aligned wildcards from them.
In the loop of lines 4-8, we only need to con-
</bodyText>
<equation confidence="0.944488047619047">
sider a
(e)
i for 0 i min{#e(D
s ),#e(D
t )}, because
a
(e)
i = 0 for the rest of i.
To sum up, Eq. 7 can be computed as below,
which is exactly the computation at lines 3-8.
g(#(D
s ),#(D
t )) =
e
(
ne
i=0
a
(e)
i 2i
) (8)
</equation>
<bodyText confidence="0.755060222222222">
For the k-gram pairs in Fig. 2, we first create
lists of doubles in Fig. 3 and compute #() for
them (lines 1-2 of Alg. 1), as shown in Fig. 5. We
next compute Kk from #(D
s ) and #(D
t ) in
Fig. 5 (lines 3-8 of Alg. 1) and obtain Kk = (1)(1+
2)(2)(24)(1 + 62 + 64) = 1212 + 2410 +
148 +26.
</bodyText>
<subsubsectionHeader confidence="0.926435">
5.2.3 Computing Kk
</subsubsectionHeader>
<bodyText confidence="0.9964503">
Algorithm 2 shows how to compute Kk. It pre-
pares two maps ms and mt and two vectors of coun-
ters cs and ct. In ms and mt, each key #N(.) maps a
set of values #(.). Counters cs and ct count the
frequency of each #(.). Recall that #N(s1 s2 )
denotes a vector whose element is #e(s1 s2 ) for
e N. #(s1 s2 ) denotes a vector whose ele-
ment is #e(s1 s2 ) where e is any possible double.
One can easily verify the output of the al-
gorithm is exactly the value of Kk. First,
</bodyText>
<equation confidence="0.518249">
Kk((s1 ,t1 ),(s2 ,t2 )) = 0 if #N(s1 s2 ) 6=
#N(t1 t2 ). Therefore, we only need to consider
</equation>
<bodyText confidence="0.990568">
those s1 s2 and t1 t2 which have the same
key (lines 10-13). We group the k-gram pairs by
their key in lines 2-5 and lines 6-9.
Moreover, the following relation holds
</bodyText>
<equation confidence="0.9687428125">
Kk((s1 ,t1 ),(s2 ,t2 )) = Kk((
0
s1
,
0
t1
),(
0
s2
,
0
t2
))
if #(s1 s2 ) = #(
0
s1
0
s2
) and #(t1
t2 ) = #(
0
t1
0
t2
), where 0
s1
, 0
s2
, 0
t1
, 0
t2
</equation>
<figure confidence="0.935828363636364">
are
Algorithm 2: Computing Kk
Input: string pair (s1,t1) and (s2,t2), window
size k
Output: Kk((s1,t1),(s2,t2))
1 Initialize two maps ms and mt and two counters
cs and ct;
2 for each k-gram s1 in s1 do
3 for each k-gram s2 in s2 do
4 Update ms with key-value pair
(#N(s1 s2 ),#(s1 s2 ));
5 cs[#(s1 s2 )]++ ;
6 for each k-gram t1 in t1 do
7 for each k-gram t2 in t2 do
8 Update mt with key-value pair
(#N(t1 t2 ),#(t1 t2 ));
9 ct[#(t1 t2 )]++ ;
10 for each key ms.keysmt.keys do
11 for each vs ms[key] do
12 for each vt mt[key] do
13 result+= cs[vs]ct[vt]g(vs,vt) ;
14 return result;
</figure>
<bodyText confidence="0.964705666666667">
other k-grams. Therefore, we only need to take
#(s1 s2 ) and #(t1 t2 ) as the value un-
der each key and count its frequency. That is to say,
# provides sufficient statistics for computing Kk.
The quantity g(vs,vt) in line 13 is computed by
Alg. 1 (lines 3-8).
</bodyText>
<subsectionHeader confidence="0.998976">
5.3 Time Complexity
</subsectionHeader>
<bodyText confidence="0.99943675">
The time complexities of Alg. 1 and Alg. 2 are
shown below.
For Alg. 1, lines 1-2 can be executed in
O(k). The time for executing line 7 is less
</bodyText>
<equation confidence="0.960138666666667">
than #e(D
s ) + #e(D
t ) + 1 for each e satisfying
#e(D
s ) 6= 0 or #e(D
t ) 6= 0 . Since e #e(D
s ) =
e #e(D
t ) = k, the time for executing lines 3-8
</equation>
<bodyText confidence="0.999684142857143">
is less than 4k, which results in the O(k) time com-
plexity of Alg. 1.
For Alg. 2, we denote n = max{|s1|,|s2|,|t1|,|t2|}.
It is easy to see that if the maps and counters in the
algorithm are implemented by hash maps, the time
complexities of lines 2-5 and lines 6-9 are O(kn2).
However, analyzing the time complexity of lines 10-
</bodyText>
<page confidence="0.998266">
454
</page>
<figure confidence="0.9763245">
\x0ca b *1 c
0
0.5
1
1.5
2
2.5
1 2 3 4 5 6 7 8
C/n
avg
2
window size K
Worst
Avg.
</figure>
<figureCaption confidence="0.999955">
Figure 6: Relation between ratio C/n2
</figureCaption>
<bodyText confidence="0.652004833333333">
avg and window size
k when running Alg. 2 on MSR Paraphrases Corpus.
13 is quite difficult.
Lemma 2 and Theorem 1 provide an upper bound
of the number of times computing g(vs,vt) in line 13,
denoted as C.
</bodyText>
<figure confidence="0.921422416666667">
Lemma 2. For s1 k-grams(s1) and s2 ,
0
s2
k-
grams(s2), we have #(s1 s2 ) =
#(s1
0
s2
) if #N(s1 s2 ) = #N(s1
0
s2
).
</figure>
<construct confidence="0.653456">
Theorem 1. C is O(n3).
</construct>
<bodyText confidence="0.974183714285714">
By Lemma 2, each ms[key] contains at most
n k + 1 elements. Together with the fact that
key ms[key] = (n k + 1)2, Theorem 1 is proved.
It can be also proved that C is O(n2) when k = 1.
Empirical study shows that O(n3) is a loose upper
bound for C. Let navg denote the average length of
s1, t1, s2 and t2. Our experiment on all pairs of sen-
tences on MSR Paraphrase (Fig. 6) shows that C is in
the same order of n2
avg in the worst case and C/n2
avg
decreases with increasing k in both average case and
worst case, which indicates that C is O(n2) and the
overall time complexity of Alg. 2 is O(kn2).
</bodyText>
<sectionHeader confidence="0.999015" genericHeader="evaluation">
6 Experiments
</sectionHeader>
<bodyText confidence="0.9995406875">
We evaluated the performances of the three types
of string re-writing kernels on paraphrase identifica-
tion and recognizing textual entailment: pairwise k-
spectrum kernel (ps-SRK), pairwise k-wildcard ker-
nel (pw-SRK), and k-gram bijective string re-writing
kernel (kb-SRK). We set = 1 for all kernels. The
performances were measured by accuracy (e.g. per-
centage of correct classifications).
In both experiments, we used LIBSVM with de-
fault parameters (Chang et al., 2011) as the clas-
sifier. All the sentences in the training and test
sets were segmented into words by the tokenizer at
OpenNLP (Baldrige et al., ). We further conducted
stemming on the words with Iveonik English Stem-
mer (http://www.iveonik.com/).
We normalized each kernel by K(x,y) =
</bodyText>
<equation confidence="0.4521265">
K(x,y)
K(x,x)K(y,y)
</equation>
<bodyText confidence="0.99854325">
and then tried them under different
window sizes k. We also tried to combine the
kernels with two lexical features unigram precision
and recall proposed in (Wan et al., 2006), referred
to as PR. For each kernel K, we tested the window
size settings of K1 + ... + Kkmax (kmax {1,2,3,4})
together with the combination with PR and we
report the best accuracies of them in Tab 1 and
</bodyText>
<subsectionHeader confidence="0.7802915">
Tab 2.
6.1 Paraphrase Identification
</subsectionHeader>
<bodyText confidence="0.999548533333333">
The task of paraphrase identification is to examine
whether two sentences have the same meaning. We
trained and tested all the methods on the MSR Para-
phrase Corpus (Dolan and Brockett, 2005; Quirk
et al., 2004) consisting of 4,076 sentence pairs for
training and 1,725 sentence pairs for testing.
The experimental results on different SRKs are
shown in Table 1. It can be seen that kb-SRK out-
performs ps-SRK and pw-SRK. The results by the
state-of-the-art methods reported in previous work
are also included in Table 1. kb-SRK outperforms
the existing lexical approach (Zhang and Patrick,
2005) and kernel approach (Lintean and Rus, 2011).
It also works better than the other approaches listed
in the table, which use syntactic trees or dependency
</bodyText>
<figureCaption confidence="0.784146">
relations.
Fig. 7 gives detailed results of the kernels under
</figureCaption>
<bodyText confidence="0.63412075">
different maximum k-gram lengths kmax with and
without PR. The results of ps-SRK and pw-SRK
without combining PR under different k are all be-
low 71%, therefore they are not shown for clar-
</bodyText>
<table confidence="0.987356666666667">
Method Acc.
Zhang and Patrick (2005) 71.9
Lintean and Rus (2011) 73.6
Heilman and Smith (2010) 73.2
Qiu et al. (2006) 72.0
Wan et al. (2006) 75.6
Das and Smith (2009) 73.9
Das and Smith (2009)(PoE) 76.1
Our baseline (PR) 73.6
Our method (ps-SRK) 75.6
Our method (pw-SRK) 75.0
Our method (kb-SRK) 76.3
</table>
<tableCaption confidence="0.999915">
Table 1: Comparison with state-of-the-arts on MSRP.
</tableCaption>
<page confidence="0.940011">
455
</page>
<figure confidence="0.993490823529412">
\x0ca b *1 c
73.5
74
74.5
75
75.5
76
76.5
1 2 3 4
Accuracy
(%)
window size kmax
kb_SRK+PR
kb_SRK
ps_SRK+PR
pw_SRK+PR
PR
</figure>
<figureCaption confidence="0.999931">
Figure 7: Performances of different kernels under differ-
</figureCaption>
<bodyText confidence="0.9978478">
ent maximum window size kmax on MSRP.
ity. By comparing the results of kb-SRK and pw-
SRK we can see that the bijective property in kb-
SRK is really helpful for improving the performance
(note that both methods use wildcards). Further-
more, the performances of kb-SRK with and without
combining PR increase dramatically with increasing
kmax and reach the peaks (better than state-of-the-art)
when kmax is four, which shows the power of the lex-
ical and structural similarity captured by kb-SRK.
</bodyText>
<subsectionHeader confidence="0.999535">
6.2 Recognizing Textual Entailment
</subsectionHeader>
<bodyText confidence="0.990499769230769">
Recognizing textual entailment is to determine
whether a sentence (sometimes a short paragraph)
can entail the other sentence (Giampiccolo et al.,
2007). RTE-3 is a widely used benchmark dataset.
Following the common practice, we combined the
development set of RTE-3 and the whole datasets of
RTE-1 and RTE-2 as training data and took the test
set of RTE-3 as test data. The train and test sets con-
tain 3,767 and 800 sentence pairs.
The results are shown in Table 2. Again, kb-SRK
outperforms ps-SRK and pw-SRK. As indicated
in (Heilman and Smith, 2010), the top-performing
RTE systems are often built with significant engi-
</bodyText>
<table confidence="0.986375727272727">
Method Acc.
Harmeling (2007) 59.5
de Marneffe et al. (2006) 60.5
M&amp;M, (2007) (NL) 59.4
M&amp;M, (2007) (Hybrid) 64.3
Zanzotto et al. (2007) 65.75
Heilman and Smith (2010) 62.8
Our baseline (PR) 62.0
Our method (ps-SRK) 64.6
Our method (pw-SRK) 63.8
Our method (kb-SRK) 65.1
</table>
<tableCaption confidence="0.984182">
Table 2: Comparison with state-of-the-arts on RTE-3.
</tableCaption>
<figure confidence="0.996799875">
a b *1 c
60.5
61.5
62.5
63.5
64.5
65.5
1 2 3 4
Accuracy
(%)
window size kmax
kb_SRK+PR
kb_SRK
ps_SRK+PR
pw_SRK+PR
PR
</figure>
<figureCaption confidence="0.999804">
Figure 8: Performances of different kernels under differ-
</figureCaption>
<bodyText confidence="0.997686066666667">
ent maximum window size kmax on RTE-3.
neering efforts. Therefore, we only compare with
the six systems which involves less engineering. kb-
SRK still outperforms most of those state-of-the-art
methods even if it does not exploit any other lexical
semantic sources and syntactic analysis tools.
Fig. 8 shows the results of the kernels under dif-
ferent parameter settings. Again, the results of ps-
SRK and pw-SRK without combining PR are too
low to be shown (all below 55%). We can see that
PR is an effective method for this dataset and the
overall performances are substantially improved af-
ter combining it with the kernels. The performance
of kb-SRK reaches the peak when window size be-
comes two.
</bodyText>
<sectionHeader confidence="0.997209" genericHeader="conclusions">
7 Conclusion
</sectionHeader>
<bodyText confidence="0.995081538461538">
In this paper, we have proposed a novel class of ker-
nel functions for sentence re-writing, called string
re-writing kernel (SRK). SRK measures the lexical
and structural similarity between two pairs of sen-
tences without using syntactic trees. The approach
is theoretically sound and is flexible to formulations
of sentences. A specific instance of SRK, referred
to as kb-SRK, has been developed which can bal-
ance the effectiveness and efficiency for sentence
re-writing. Experimental results show that kb-SRK
achieve better results than state-of-the-art methods
on paraphrase identification and recognizing textual
entailment.
</bodyText>
<sectionHeader confidence="0.976561" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.8990885">
This work is supported by the National Basic Re-
search Program (973 Program) No. 2012CB316301.
</bodyText>
<sectionHeader confidence="0.950291" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.9643665">
Baldrige, J. , Morton, T. and Bierner G. OpenNLP.
http://opennlp.sourceforge.net/.
</reference>
<page confidence="0.980654">
456
</page>
<reference confidence="0.999724783018868">
\x0cBarzilay, R. and Lee, L. 2003. Learning to paraphrase:
An unsupervised approach using multiple-sequence
alignment. Proceedings of the 2003 Conference of the
North American Chapter of the Association for Com-
putational Linguistics on Human Language Technol-
ogy, pp. 1623.
Basilico, J. and Hofmann, T. 2004. Unifying collab-
orative and content-based filtering. Proceedings of
the twenty-first international conference on Machine
learning, pp. 9, 2004.
Ben-Hur, A. and Noble, W.S. 2005. Kernel methods for
predicting proteinprotein interactions. Bioinformat-
ics, vol. 21, pp. i38i46, Oxford Univ Press.
Bhagat, R. and Ravichandran, D. 2008. Large scale ac-
quisition of paraphrases for learning surface patterns.
Proceedings of ACL-08: HLT, pp. 674682.
Chang, C. and Lin, C. 2011. LIBSVM: A library for sup-
port vector machines. ACM Transactions on Intelli-
gent Systems and Technology vol. 2, issue 3, pp. 27:1
27:27. Software available at http://www.csie.
ntu.edu.tw/ cjlin/libsvm
Das, D. and Smith, N.A. 2009. Paraphrase identifi-
cation as probabilistic quasi-synchronous recognition.
Proceedings of the Joint Conference of the 47th An-
nual Meeting of the ACL and the 4th International
Joint Conference on Natural Language Processing of
the AFNLP, pp. 468476.
de Marneffe, M., MacCartney, B., Grenager, T., Cer, D.,
Rafferty A. and Manning C.D. 2006. Learning to dis-
tinguish valid textual entailments. Proc. of the Second
PASCAL Challenges Workshop.
Dolan, W.B. and Brockett, C. 2005. Automatically con-
structing a corpus of sentential paraphrases. Proc. of
IWP.
Giampiccolo, D., Magnini B., Dagan I., and Dolan B.,
editors 2007. The third pascal recognizing textual en-
tailment challenge. Proceedings of the ACL-PASCAL
Workshop on Textual Entailment and Paraphrasing,
pp. 19.
Harmeling, S. 2007. An extensible probabilistic
transformation-based approach to the third recogniz-
ing textual entailment challenge. Proceedings of the
ACL-PASCAL Workshop on Textual Entailment and
Paraphrasing, pp. 137142, 2007.
Heilman, M. and Smith, N.A. 2010. Tree edit models for
recognizing textual entailments, paraphrases, and an-
swers to questions. Human Language Technologies:
The 2010 Annual Conference of the North American
Chapter of the Association for Computational Linguis-
tics, pp. 1011-1019.
Kashima, H. , Oyama, S. , Yamanishi, Y. and Tsuda, K.
2009. On pairwise kernels: An efficient alternative
and generalization analysis. Advances in Knowledge
Discovery and Data Mining, pp. 1030-1037, 2009,
Springer.
Kimeldorf, G. and Wahba, G. 1971. Some results on
Tchebycheffian spline functions. Journal of Mathemat-
ical Analysis and Applications, Vol.33, No.1, pp.82-
95, Elsevier.
Lin, D. and Pantel, P. 2001. DIRT-discovery of inference
rules from text. Proc. of ACM SIGKDD Conference
on Knowledge Discovery and Data Mining.
Lintean, M. and Rus, V. 2011. Dissimilarity Kernels
for Paraphrase Identification. Twenty-Fourth Interna-
tional FLAIRS Conference.
Leslie, C. , Eskin, E. and Noble, W.S. 2002. The spec-
trum kernel: a string kernel for SVM protein classifi-
cation. Pacific symposium on biocomputing vol. 575,
pp. 564-575, Hawaii, USA.
Leslie, C. and Kuang, R. 2004. Fast string kernels using
inexact matching for protein sequences. The Journal
of Machine Learning Research vol. 5, pp. 1435-1455.
Lodhi, H. , Saunders, C. , Shawe-Taylor, J. , Cristianini,
N. and Watkins, C. 2002. Text classification using
string kernels. The Journal of Machine Learning Re-
search vol. 2, pp. 419-444.
MacCartney, B. and Manning, C.D. 2008. Modeling se-
mantic containment and exclusion in natural language
inference. Proceedings of the 22nd International Con-
ference on Computational Linguistics, vol. 1, pp. 521-
528, 2008.
Moschitti, A. and Zanzotto, F.M. 2007. Fast and Effec-
tive Kernels for Relational Learning from Texts. Pro-
ceedings of the 24th Annual International Conference
on Machine Learning, Corvallis, OR, USA, 2007.
Qiu, L. and Kan, M.Y. and Chua, T.S. 2006. Para-
phrase recognition via dissimilarity significance clas-
sification. Proceedings of the 2006 Conference on
Empirical Methods in Natural Language Processing,
pp. 1826.
Quirk, C. , Brockett, C. and Dolan, W. 2004. Monolin-
gual machine translation for paraphrase generation.
Proceedings of EMNLP 2004, pp. 142-149, Barcelona,
Spain.
Scholkopf, B. and Smola, A.J. 2002. Learning with
kernels: Support vector machines, regularization, op-
timization, and beyond. The MIT Press, Cambridge,
MA.
Vapnik, V.N. 2000. The nature of statistical learning
theory. Springer Verlag.
Wan, S. , Dras, M. , Dale, R. and Paris, C. 2006. Using
dependency-based features to take the Para-farce
out of paraphrase. Proc. of the Australasian Language
Technology Workshop, pp. 131138.
Zanzotto, F.M. , Pennacchiotti, M. and Moschitti, A.
2007. Shallow semantics in fast textual entailment
</reference>
<page confidence="0.960733">
457
</page>
<reference confidence="0.994776">
\x0crule learners. Proceedings of the ACL-PASCAL
workshop on textual entailment and paraphrasing, pp.
7277.
Zhang, Y. and Patrick, J. 2005. Paraphrase identifica-
tion by text canonicalization. Proceedings of the Aus-
tralasian Language Technology Workshop, pp. 160
166.
</reference>
<page confidence="0.980416">
458
</page>
<figure confidence="0.251001">
\x0c&apos;
</figure>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.137870">
<note confidence="0.977731">b&apos;Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics, pages 449458, Jeju, Republic of Korea, 8-14 July 2012. c 2012 Association for Computational Linguistics</note>
<title confidence="0.881778">String Re-writing Kernel</title>
<author confidence="0.816417">Fan Bu</author>
<author confidence="0.816417">Hang Li</author>
<author confidence="0.816417">Xiaoyan Zhu</author>
<affiliation confidence="0.677126">1,3State Key Laboratory of Intelligent Technology and Systems 1,3Tsinghua National Laboratory for Information Sci. and Tech. 1,3Department of Computer Sci. and Tech., Tsinghua University 2Microsoft Research Asia, No. 5 Danling Street, Beijing 100080,China</affiliation>
<email confidence="0.878920333333333">1bufan0000@gmail.com2hangli@microsoft.com3zxy-dcs@tsinghua.edu.cn</email>
<abstract confidence="0.98852725">Learning for sentence re-writing is a fundamental task in natural language processing and information retrieval. In this paper, we propose a new class of kernel functions, referred to as string re-writing kernel, to address the problem. A string re-writing kernel measures the similarity between two pairs of strings, each pair representing re-writing of a string. It can capture the lexical and structural similarity between two pairs of sentences without the need of constructing syntactic trees. We further propose an instance of string rewriting kernel which can be computed efficiently. Experimental results on benchmark datasets show that our method can achieve better results than state-of-the-art methods on two sentence re-writing learning tasks: paraphrase identification and recognizing textual entailment.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>R \x0cBarzilay</author>
<author>L Lee</author>
</authors>
<title>Learning to paraphrase: An unsupervised approach using multiple-sequence alignment.</title>
<date>2003</date>
<booktitle>Proceedings of the 2003 Conference of the North American Chapter of the Association for Computational Linguistics on Human Language Technology,</booktitle>
<pages>1623</pages>
<marker>\x0cBarzilay, Lee, 2003</marker>
<rawString>\x0cBarzilay, R. and Lee, L. 2003. Learning to paraphrase: An unsupervised approach using multiple-sequence alignment. Proceedings of the 2003 Conference of the North American Chapter of the Association for Computational Linguistics on Human Language Technology, pp. 1623.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Basilico</author>
<author>T Hofmann</author>
</authors>
<title>Unifying collaborative and content-based filtering.</title>
<date>2004</date>
<booktitle>Proceedings of the twenty-first international conference on Machine learning,</booktitle>
<pages>9</pages>
<contexts>
<context position="4653" citStr="Basilico and Hofmann, 2004" startWordPosition="712" endWordPosition="716">ng kernel function, first proposed by Lodhi et al. (2002), measures the similarity between two strings by their shared substrings. Leslie et al. (2002) proposed the k-spectrum kernel which represents strings by their contiguous substrings of length k. Leslie et al. (2004) further proposed a number of string kernels including the wildcard kernel to facilitate inexact matching between the strings. The string kernels defined on two pairs of objects (including strings) were also developed, which decompose the similarity into product of similarities between individual objects using tensor product (Basilico and Hofmann, 2004; Ben-Hur and Noble, 2005) or Cartesian product (Kashima et al., 2009). The task of paraphrasing usually consists of paraphrase pattern generation and paraphrase identification. Paraphrase pattern generation is to automatically extract semantically equivalent patterns (Lin and Pantel, 2001; Bhagat and Ravichandran, 2008) or sentences (Barzilay and Lee, 2003). Paraphrase identification is to identify whether two given sentences are a paraphrase of each other. The methods proposed so far formalized the problem as classification and used various types of features such as bag-of-words feature, edi</context>
</contexts>
<marker>Basilico, Hofmann, 2004</marker>
<rawString>Basilico, J. and Hofmann, T. 2004. Unifying collaborative and content-based filtering. Proceedings of the twenty-first international conference on Machine learning, pp. 9, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Ben-Hur</author>
<author>W S Noble</author>
</authors>
<title>Kernel methods for predicting proteinprotein interactions.</title>
<date>2005</date>
<journal>Bioinformatics,</journal>
<volume>21</volume>
<pages>38--46</pages>
<publisher>Univ Press.</publisher>
<location>Oxford</location>
<contexts>
<context position="4679" citStr="Ben-Hur and Noble, 2005" startWordPosition="717" endWordPosition="720">oposed by Lodhi et al. (2002), measures the similarity between two strings by their shared substrings. Leslie et al. (2002) proposed the k-spectrum kernel which represents strings by their contiguous substrings of length k. Leslie et al. (2004) further proposed a number of string kernels including the wildcard kernel to facilitate inexact matching between the strings. The string kernels defined on two pairs of objects (including strings) were also developed, which decompose the similarity into product of similarities between individual objects using tensor product (Basilico and Hofmann, 2004; Ben-Hur and Noble, 2005) or Cartesian product (Kashima et al., 2009). The task of paraphrasing usually consists of paraphrase pattern generation and paraphrase identification. Paraphrase pattern generation is to automatically extract semantically equivalent patterns (Lin and Pantel, 2001; Bhagat and Ravichandran, 2008) or sentences (Barzilay and Lee, 2003). Paraphrase identification is to identify whether two given sentences are a paraphrase of each other. The methods proposed so far formalized the problem as classification and used various types of features such as bag-of-words feature, edit distance (Zhang and Patr</context>
</contexts>
<marker>Ben-Hur, Noble, 2005</marker>
<rawString>Ben-Hur, A. and Noble, W.S. 2005. Kernel methods for predicting proteinprotein interactions. Bioinformatics, vol. 21, pp. i38i46, Oxford Univ Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Bhagat</author>
<author>D Ravichandran</author>
</authors>
<title>Large scale acquisition of paraphrases for learning surface patterns.</title>
<date>2008</date>
<booktitle>Proceedings of ACL-08: HLT,</booktitle>
<pages>674682</pages>
<contexts>
<context position="4975" citStr="Bhagat and Ravichandran, 2008" startWordPosition="758" endWordPosition="761">ncluding the wildcard kernel to facilitate inexact matching between the strings. The string kernels defined on two pairs of objects (including strings) were also developed, which decompose the similarity into product of similarities between individual objects using tensor product (Basilico and Hofmann, 2004; Ben-Hur and Noble, 2005) or Cartesian product (Kashima et al., 2009). The task of paraphrasing usually consists of paraphrase pattern generation and paraphrase identification. Paraphrase pattern generation is to automatically extract semantically equivalent patterns (Lin and Pantel, 2001; Bhagat and Ravichandran, 2008) or sentences (Barzilay and Lee, 2003). Paraphrase identification is to identify whether two given sentences are a paraphrase of each other. The methods proposed so far formalized the problem as classification and used various types of features such as bag-of-words feature, edit distance (Zhang and Patrick, 2005), dissimilarity kernel (Lintean and Rus, 2011) predicate-argument structure (Qiu et al., 2006), and tree edit model (which is based on a tree kernel) (Heilman and Smith, 2010) in the classification task. Among the most successful methods, Wan et al. (2006) enriched the feature set by t</context>
</contexts>
<marker>Bhagat, Ravichandran, 2008</marker>
<rawString>Bhagat, R. and Ravichandran, D. 2008. Large scale acquisition of paraphrases for learning surface patterns. Proceedings of ACL-08: HLT, pp. 674682.</rawString>
</citation>
<citation valid="false">
<authors>
<author>C Chang</author>
<author>C Lin</author>
</authors>
<title>LIBSVM: A library for support vector machines.</title>
<date>2011</date>
<journal>ACM Transactions on Intelligent Systems and Technology</journal>
<booktitle>Proceedings of the Joint Conference of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP,</booktitle>
<volume>2</volume>
<pages>27--1</pages>
<marker>Chang, Lin, 2011</marker>
<rawString>Chang, C. and Lin, C. 2011. LIBSVM: A library for support vector machines. ACM Transactions on Intelligent Systems and Technology vol. 2, issue 3, pp. 27:1 27:27. Software available at http://www.csie. ntu.edu.tw/ cjlin/libsvm Das, D. and Smith, N.A. 2009. Paraphrase identification as probabilistic quasi-synchronous recognition. Proceedings of the Joint Conference of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP, pp. 468476.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M de Marneffe</author>
<author>B MacCartney</author>
<author>T Grenager</author>
<author>D Cer</author>
<author>A Rafferty</author>
<author>C D Manning</author>
</authors>
<title>Learning to distinguish valid textual entailments.</title>
<date>2006</date>
<booktitle>Proc. of the Second PASCAL Challenges Workshop.</booktitle>
<marker>de Marneffe, MacCartney, Grenager, Cer, Rafferty, Manning, 2006</marker>
<rawString>de Marneffe, M., MacCartney, B., Grenager, T., Cer, D., Rafferty A. and Manning C.D. 2006. Learning to distinguish valid textual entailments. Proc. of the Second PASCAL Challenges Workshop.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W B Dolan</author>
<author>C Brockett</author>
</authors>
<title>Automatically constructing a corpus of sentential paraphrases.</title>
<date>2005</date>
<booktitle>Proc. of IWP.</booktitle>
<contexts>
<context position="24792" citStr="Dolan and Brockett, 2005" startWordPosition="4624" endWordPosition="4627">(x,y) K(x,x)K(y,y) and then tried them under different window sizes k. We also tried to combine the kernels with two lexical features unigram precision and recall proposed in (Wan et al., 2006), referred to as PR. For each kernel K, we tested the window size settings of K1 + ... + Kkmax (kmax {1,2,3,4}) together with the combination with PR and we report the best accuracies of them in Tab 1 and Tab 2. 6.1 Paraphrase Identification The task of paraphrase identification is to examine whether two sentences have the same meaning. We trained and tested all the methods on the MSR Paraphrase Corpus (Dolan and Brockett, 2005; Quirk et al., 2004) consisting of 4,076 sentence pairs for training and 1,725 sentence pairs for testing. The experimental results on different SRKs are shown in Table 1. It can be seen that kb-SRK outperforms ps-SRK and pw-SRK. The results by the state-of-the-art methods reported in previous work are also included in Table 1. kb-SRK outperforms the existing lexical approach (Zhang and Patrick, 2005) and kernel approach (Lintean and Rus, 2011). It also works better than the other approaches listed in the table, which use syntactic trees or dependency relations. Fig. 7 gives detailed results </context>
</contexts>
<marker>Dolan, Brockett, 2005</marker>
<rawString>Dolan, W.B. and Brockett, C. 2005. Automatically constructing a corpus of sentential paraphrases. Proc. of IWP.</rawString>
</citation>
<citation valid="false">
<authors>
<author>D Giampiccolo</author>
<author>B Magnini</author>
<author>I Dagan</author>
<author>B Dolan</author>
</authors>
<title>editors 2007. The third pascal recognizing textual entailment challenge.</title>
<booktitle>Proceedings of the ACL-PASCAL Workshop on Textual Entailment and Paraphrasing,</booktitle>
<pages>19</pages>
<marker>Giampiccolo, Magnini, Dagan, Dolan, </marker>
<rawString>Giampiccolo, D., Magnini B., Dagan I., and Dolan B., editors 2007. The third pascal recognizing textual entailment challenge. Proceedings of the ACL-PASCAL Workshop on Textual Entailment and Paraphrasing, pp. 19.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Harmeling</author>
</authors>
<title>An extensible probabilistic transformation-based approach to the third recognizing textual entailment challenge.</title>
<date>2007</date>
<booktitle>Proceedings of the ACL-PASCAL Workshop on Textual Entailment and Paraphrasing,</booktitle>
<pages>137142</pages>
<contexts>
<context position="6236" citStr="Harmeling (2007)" startWordPosition="960" endWordPosition="961">and Smith (2009) used the quasi-synchronous grammar formalism to incorporate features from WordNet, named entity recognizer, POS tagger, and dependency labels from aligned trees. The task of recognizing textual entailment is to decide whether the hypothesis sentence can be entailed by the premise sentence (Giampiccolo et al., 2007). In recognizing textual entailment, de Marneffe et al. (2006) classified sentences pairs on the basis of word alignments. MacCartney and Manning (2008) used an inference procedure based on natural logic and combined it with the methods by de Marneffe et al. (2006). Harmeling (2007) and Heilman and Smith (2010) classified sequence pairs based on transformation on syntactic trees. Zanzotto et al. (2007) used a kernel method on syntactic tree pairs (Moschitti and Zanzotto, 2007). 3 Kernel Approach to Sentence Re-Writing Learning We formalize sentence re-writing learning as a kernel method. Following the literature of string kernel, we use the terms string and character instead of sentence and word. Suppose that we are given training data consisting of re-writings of strings and their responses ((s1,t1),y1),...,((sn,tn),yn) ( )Y where denotes the character set, = S i=0 i de</context>
<context position="27310" citStr="Harmeling (2007)" startWordPosition="5045" endWordPosition="5046"> determine whether a sentence (sometimes a short paragraph) can entail the other sentence (Giampiccolo et al., 2007). RTE-3 is a widely used benchmark dataset. Following the common practice, we combined the development set of RTE-3 and the whole datasets of RTE-1 and RTE-2 as training data and took the test set of RTE-3 as test data. The train and test sets contain 3,767 and 800 sentence pairs. The results are shown in Table 2. Again, kb-SRK outperforms ps-SRK and pw-SRK. As indicated in (Heilman and Smith, 2010), the top-performing RTE systems are often built with significant engiMethod Acc. Harmeling (2007) 59.5 de Marneffe et al. (2006) 60.5 M&amp;M, (2007) (NL) 59.4 M&amp;M, (2007) (Hybrid) 64.3 Zanzotto et al. (2007) 65.75 Heilman and Smith (2010) 62.8 Our baseline (PR) 62.0 Our method (ps-SRK) 64.6 Our method (pw-SRK) 63.8 Our method (kb-SRK) 65.1 Table 2: Comparison with state-of-the-arts on RTE-3. a b *1 c 60.5 61.5 62.5 63.5 64.5 65.5 1 2 3 4 Accuracy (%) window size kmax kb_SRK+PR kb_SRK ps_SRK+PR pw_SRK+PR PR Figure 8: Performances of different kernels under different maximum window size kmax on RTE-3. neering efforts. Therefore, we only compare with the six systems which involves less engineer</context>
</contexts>
<marker>Harmeling, 2007</marker>
<rawString>Harmeling, S. 2007. An extensible probabilistic transformation-based approach to the third recognizing textual entailment challenge. Proceedings of the ACL-PASCAL Workshop on Textual Entailment and Paraphrasing, pp. 137142, 2007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Heilman</author>
<author>N A Smith</author>
</authors>
<title>Tree edit models for recognizing textual entailments, paraphrases, and answers to questions. Human Language Technologies: The</title>
<date>2010</date>
<booktitle>Annual Conference of the North American Chapter of the Association for Computational Linguistics,</booktitle>
<pages>1011--1019</pages>
<contexts>
<context position="2228" citStr="Heilman and Smith, 2010" startWordPosition="329" endWordPosition="332">ween query and document title in search. The key question here is how to represent the rewriting of sentences. In previous research on sentence re-writing learning such as paraphrase identification and recognizing textual entailment, most representations are based on the lexicons (Zhang and Patrick, 2005; Lintean and Rus, 2011; de Marneffe et al., 2006) or the syntactic trees (Das and Smith, wrote . Shakespeare wrote Hamlet. * was written by . Hamlet was written by Shakespeare. (B) * * * * (A) Figure 1: Example of re-writing. (A) is a re-writing rule and (B) is a re-writing of sentence. 2009; Heilman and Smith, 2010) of the sentence pairs. In (Lin and Pantel, 2001; Barzilay and Lee, 2003), re-writing rules serve as underlying representations for paraphrase generation/discovery. Motivated by the work, we represent re-writing of sentences by all possible re-writing rules that can be applied into it. For example, in Fig. 1, (A) is one re-writing rule that can be applied into the sentence re-writing (B). Specifically, we propose a new class of kernel functions (Scholkopf and Smola, 2002), called string rewriting kernel (SRK), which defines the similarity between two re-writings (pairs) of strings as the inner</context>
<context position="5464" citStr="Heilman and Smith, 2010" startWordPosition="835" endWordPosition="838">e pattern generation is to automatically extract semantically equivalent patterns (Lin and Pantel, 2001; Bhagat and Ravichandran, 2008) or sentences (Barzilay and Lee, 2003). Paraphrase identification is to identify whether two given sentences are a paraphrase of each other. The methods proposed so far formalized the problem as classification and used various types of features such as bag-of-words feature, edit distance (Zhang and Patrick, 2005), dissimilarity kernel (Lintean and Rus, 2011) predicate-argument structure (Qiu et al., 2006), and tree edit model (which is based on a tree kernel) (Heilman and Smith, 2010) in the classification task. Among the most successful methods, Wan et al. (2006) enriched the feature set by the BLEU metric and dependency relations. Das and Smith (2009) used the quasi-synchronous grammar formalism to incorporate features from WordNet, named entity recognizer, POS tagger, and dependency labels from aligned trees. The task of recognizing textual entailment is to decide whether the hypothesis sentence can be entailed by the premise sentence (Giampiccolo et al., 2007). In recognizing textual entailment, de Marneffe et al. (2006) classified sentences pairs on the basis of word </context>
<context position="25694" citStr="Heilman and Smith (2010)" startWordPosition="4773" endWordPosition="4776">orted in previous work are also included in Table 1. kb-SRK outperforms the existing lexical approach (Zhang and Patrick, 2005) and kernel approach (Lintean and Rus, 2011). It also works better than the other approaches listed in the table, which use syntactic trees or dependency relations. Fig. 7 gives detailed results of the kernels under different maximum k-gram lengths kmax with and without PR. The results of ps-SRK and pw-SRK without combining PR under different k are all below 71%, therefore they are not shown for clarMethod Acc. Zhang and Patrick (2005) 71.9 Lintean and Rus (2011) 73.6 Heilman and Smith (2010) 73.2 Qiu et al. (2006) 72.0 Wan et al. (2006) 75.6 Das and Smith (2009) 73.9 Das and Smith (2009)(PoE) 76.1 Our baseline (PR) 73.6 Our method (ps-SRK) 75.6 Our method (pw-SRK) 75.0 Our method (kb-SRK) 76.3 Table 1: Comparison with state-of-the-arts on MSRP. 455 \x0ca b *1 c 73.5 74 74.5 75 75.5 76 76.5 1 2 3 4 Accuracy (%) window size kmax kb_SRK+PR kb_SRK ps_SRK+PR pw_SRK+PR PR Figure 7: Performances of different kernels under different maximum window size kmax on MSRP. ity. By comparing the results of kb-SRK and pwSRK we can see that the bijective property in kbSRK is really helpful for imp</context>
<context position="27212" citStr="Heilman and Smith, 2010" startWordPosition="5029" endWordPosition="5032">ral similarity captured by kb-SRK. 6.2 Recognizing Textual Entailment Recognizing textual entailment is to determine whether a sentence (sometimes a short paragraph) can entail the other sentence (Giampiccolo et al., 2007). RTE-3 is a widely used benchmark dataset. Following the common practice, we combined the development set of RTE-3 and the whole datasets of RTE-1 and RTE-2 as training data and took the test set of RTE-3 as test data. The train and test sets contain 3,767 and 800 sentence pairs. The results are shown in Table 2. Again, kb-SRK outperforms ps-SRK and pw-SRK. As indicated in (Heilman and Smith, 2010), the top-performing RTE systems are often built with significant engiMethod Acc. Harmeling (2007) 59.5 de Marneffe et al. (2006) 60.5 M&amp;M, (2007) (NL) 59.4 M&amp;M, (2007) (Hybrid) 64.3 Zanzotto et al. (2007) 65.75 Heilman and Smith (2010) 62.8 Our baseline (PR) 62.0 Our method (ps-SRK) 64.6 Our method (pw-SRK) 63.8 Our method (kb-SRK) 65.1 Table 2: Comparison with state-of-the-arts on RTE-3. a b *1 c 60.5 61.5 62.5 63.5 64.5 65.5 1 2 3 4 Accuracy (%) window size kmax kb_SRK+PR kb_SRK ps_SRK+PR pw_SRK+PR PR Figure 8: Performances of different kernels under different maximum window size kmax on RT</context>
</contexts>
<marker>Heilman, Smith, 2010</marker>
<rawString>Heilman, M. and Smith, N.A. 2010. Tree edit models for recognizing textual entailments, paraphrases, and answers to questions. Human Language Technologies: The 2010 Annual Conference of the North American Chapter of the Association for Computational Linguistics, pp. 1011-1019.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Oyama</author>
</authors>
<title>On pairwise kernels: An efficient alternative and generalization analysis.</title>
<date>2009</date>
<booktitle>Advances in Knowledge Discovery and Data Mining,</booktitle>
<pages>1030--1037</pages>
<publisher>Springer.</publisher>
<marker>Oyama, 2009</marker>
<rawString>Kashima, H. , Oyama, S. , Yamanishi, Y. and Tsuda, K. 2009. On pairwise kernels: An efficient alternative and generalization analysis. Advances in Knowledge Discovery and Data Mining, pp. 1030-1037, 2009, Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Kimeldorf</author>
<author>G Wahba</author>
</authors>
<title>Some results on Tchebycheffian spline functions.</title>
<date>1971</date>
<journal>Journal of Mathematical Analysis and Applications,</journal>
<volume>33</volume>
<pages>82--95</pages>
<publisher>Elsevier.</publisher>
<contexts>
<context position="7831" citStr="Kimeldorf and Wahba, 1971" startWordPosition="1229" endWordPosition="1233">. Given a new string re-writing (s,t) , our goal is to predict its response y. That is, the training data consists of binary classes of string re-writings, and the prediction is made for the new re-writing based on learning from the training data. We take the kernel approach to address the learning task. The kernel on re-writings of strings is defined as K : ( )( ) R satisfying for all (si,ti), (sj,tj) , K((si,ti),(sj,tj)) = h(si,ti),(sj,tj)i where maps each re-writing (pair) of strings into a high dimensional Hilbert space H , referred to as 450 \x0cfeature space. By the representer theorem (Kimeldorf and Wahba, 1971; Scholkopf and Smola, 2002), it can be shown that the response y of a new string re-writing (s,t) can always be represented as y = sign( n i=1 iyiK((si,ti),(s,t))) where i 0,(i = 1, ,n) are parameters. That is, it is determined by a linear combination of the similarities between the new instance and the instances in training set. It is also known that by employing a learning model such as SVM (Vapnik, 2000), such a linear combination can be automatically learned by solving a quadratic optimization problem. The question then becomes how to design the kernel function for the task. 4 String Re-w</context>
</contexts>
<marker>Kimeldorf, Wahba, 1971</marker>
<rawString>Kimeldorf, G. and Wahba, G. 1971. Some results on Tchebycheffian spline functions. Journal of Mathematical Analysis and Applications, Vol.33, No.1, pp.82-95, Elsevier.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Lin</author>
<author>P Pantel</author>
</authors>
<title>DIRT-discovery of inference rules from text.</title>
<date>2001</date>
<booktitle>Proc. of ACM SIGKDD Conference on Knowledge Discovery and Data Mining.</booktitle>
<contexts>
<context position="2276" citStr="Lin and Pantel, 2001" startWordPosition="338" endWordPosition="341">stion here is how to represent the rewriting of sentences. In previous research on sentence re-writing learning such as paraphrase identification and recognizing textual entailment, most representations are based on the lexicons (Zhang and Patrick, 2005; Lintean and Rus, 2011; de Marneffe et al., 2006) or the syntactic trees (Das and Smith, wrote . Shakespeare wrote Hamlet. * was written by . Hamlet was written by Shakespeare. (B) * * * * (A) Figure 1: Example of re-writing. (A) is a re-writing rule and (B) is a re-writing of sentence. 2009; Heilman and Smith, 2010) of the sentence pairs. In (Lin and Pantel, 2001; Barzilay and Lee, 2003), re-writing rules serve as underlying representations for paraphrase generation/discovery. Motivated by the work, we represent re-writing of sentences by all possible re-writing rules that can be applied into it. For example, in Fig. 1, (A) is one re-writing rule that can be applied into the sentence re-writing (B). Specifically, we propose a new class of kernel functions (Scholkopf and Smola, 2002), called string rewriting kernel (SRK), which defines the similarity between two re-writings (pairs) of strings as the inner product between them in the feature space induc</context>
<context position="4943" citStr="Lin and Pantel, 2001" startWordPosition="754" endWordPosition="757">er of string kernels including the wildcard kernel to facilitate inexact matching between the strings. The string kernels defined on two pairs of objects (including strings) were also developed, which decompose the similarity into product of similarities between individual objects using tensor product (Basilico and Hofmann, 2004; Ben-Hur and Noble, 2005) or Cartesian product (Kashima et al., 2009). The task of paraphrasing usually consists of paraphrase pattern generation and paraphrase identification. Paraphrase pattern generation is to automatically extract semantically equivalent patterns (Lin and Pantel, 2001; Bhagat and Ravichandran, 2008) or sentences (Barzilay and Lee, 2003). Paraphrase identification is to identify whether two given sentences are a paraphrase of each other. The methods proposed so far formalized the problem as classification and used various types of features such as bag-of-words feature, edit distance (Zhang and Patrick, 2005), dissimilarity kernel (Lintean and Rus, 2011) predicate-argument structure (Qiu et al., 2006), and tree edit model (which is based on a tree kernel) (Heilman and Smith, 2010) in the classification task. Among the most successful methods, Wan et al. (200</context>
</contexts>
<marker>Lin, Pantel, 2001</marker>
<rawString>Lin, D. and Pantel, P. 2001. DIRT-discovery of inference rules from text. Proc. of ACM SIGKDD Conference on Knowledge Discovery and Data Mining.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Lintean</author>
<author>V Rus</author>
</authors>
<title>Dissimilarity Kernels for Paraphrase Identification.</title>
<date>2011</date>
<booktitle>Twenty-Fourth International FLAIRS Conference.</booktitle>
<contexts>
<context position="1932" citStr="Lintean and Rus, 2011" startWordPosition="274" endWordPosition="277">tence re-writing learning tasks: paraphrase identification and recognizing textual entailment. 1 Introduction Learning for sentence re-writing is a fundamental task in natural language processing and information retrieval, which includes paraphrasing, textual entailment and transformation between query and document title in search. The key question here is how to represent the rewriting of sentences. In previous research on sentence re-writing learning such as paraphrase identification and recognizing textual entailment, most representations are based on the lexicons (Zhang and Patrick, 2005; Lintean and Rus, 2011; de Marneffe et al., 2006) or the syntactic trees (Das and Smith, wrote . Shakespeare wrote Hamlet. * was written by . Hamlet was written by Shakespeare. (B) * * * * (A) Figure 1: Example of re-writing. (A) is a re-writing rule and (B) is a re-writing of sentence. 2009; Heilman and Smith, 2010) of the sentence pairs. In (Lin and Pantel, 2001; Barzilay and Lee, 2003), re-writing rules serve as underlying representations for paraphrase generation/discovery. Motivated by the work, we represent re-writing of sentences by all possible re-writing rules that can be applied into it. For example, in F</context>
<context position="5335" citStr="Lintean and Rus, 2011" startWordPosition="814" endWordPosition="817">al., 2009). The task of paraphrasing usually consists of paraphrase pattern generation and paraphrase identification. Paraphrase pattern generation is to automatically extract semantically equivalent patterns (Lin and Pantel, 2001; Bhagat and Ravichandran, 2008) or sentences (Barzilay and Lee, 2003). Paraphrase identification is to identify whether two given sentences are a paraphrase of each other. The methods proposed so far formalized the problem as classification and used various types of features such as bag-of-words feature, edit distance (Zhang and Patrick, 2005), dissimilarity kernel (Lintean and Rus, 2011) predicate-argument structure (Qiu et al., 2006), and tree edit model (which is based on a tree kernel) (Heilman and Smith, 2010) in the classification task. Among the most successful methods, Wan et al. (2006) enriched the feature set by the BLEU metric and dependency relations. Das and Smith (2009) used the quasi-synchronous grammar formalism to incorporate features from WordNet, named entity recognizer, POS tagger, and dependency labels from aligned trees. The task of recognizing textual entailment is to decide whether the hypothesis sentence can be entailed by the premise sentence (Giampic</context>
<context position="25241" citStr="Lintean and Rus, 2011" startWordPosition="4696" endWordPosition="4699">phrase identification is to examine whether two sentences have the same meaning. We trained and tested all the methods on the MSR Paraphrase Corpus (Dolan and Brockett, 2005; Quirk et al., 2004) consisting of 4,076 sentence pairs for training and 1,725 sentence pairs for testing. The experimental results on different SRKs are shown in Table 1. It can be seen that kb-SRK outperforms ps-SRK and pw-SRK. The results by the state-of-the-art methods reported in previous work are also included in Table 1. kb-SRK outperforms the existing lexical approach (Zhang and Patrick, 2005) and kernel approach (Lintean and Rus, 2011). It also works better than the other approaches listed in the table, which use syntactic trees or dependency relations. Fig. 7 gives detailed results of the kernels under different maximum k-gram lengths kmax with and without PR. The results of ps-SRK and pw-SRK without combining PR under different k are all below 71%, therefore they are not shown for clarMethod Acc. Zhang and Patrick (2005) 71.9 Lintean and Rus (2011) 73.6 Heilman and Smith (2010) 73.2 Qiu et al. (2006) 72.0 Wan et al. (2006) 75.6 Das and Smith (2009) 73.9 Das and Smith (2009)(PoE) 76.1 Our baseline (PR) 73.6 Our method (ps-</context>
</contexts>
<marker>Lintean, Rus, 2011</marker>
<rawString>Lintean, M. and Rus, V. 2011. Dissimilarity Kernels for Paraphrase Identification. Twenty-Fourth International FLAIRS Conference.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Eskin</author>
<author>W S Noble</author>
</authors>
<title>The spectrum kernel: a string kernel for SVM protein classification. Pacific symposium on biocomputing</title>
<date>2002</date>
<volume>575</volume>
<pages>564--575</pages>
<location>Hawaii, USA.</location>
<marker>Eskin, Noble, 2002</marker>
<rawString>Leslie, C. , Eskin, E. and Noble, W.S. 2002. The spectrum kernel: a string kernel for SVM protein classification. Pacific symposium on biocomputing vol. 575, pp. 564-575, Hawaii, USA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Leslie</author>
<author>R Kuang</author>
</authors>
<title>Fast string kernels using inexact matching for protein sequences.</title>
<date>2004</date>
<journal>The Journal of Machine Learning Research</journal>
<volume>5</volume>
<pages>1435--1455</pages>
<marker>Leslie, Kuang, 2004</marker>
<rawString>Leslie, C. and Kuang, R. 2004. Fast string kernels using inexact matching for protein sequences. The Journal of Machine Learning Research vol. 5, pp. 1435-1455.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Shawe-Taylor</author>
</authors>
<title>Text classification using string kernels.</title>
<date>2002</date>
<journal>The Journal of Machine Learning Research</journal>
<volume>2</volume>
<pages>419--444</pages>
<marker>Shawe-Taylor, 2002</marker>
<rawString>Lodhi, H. , Saunders, C. , Shawe-Taylor, J. , Cristianini, N. and Watkins, C. 2002. Text classification using string kernels. The Journal of Machine Learning Research vol. 2, pp. 419-444.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B MacCartney</author>
<author>C D Manning</author>
</authors>
<title>Modeling semantic containment and exclusion in natural language inference.</title>
<date>2008</date>
<booktitle>Proceedings of the 22nd International Conference on Computational Linguistics,</booktitle>
<volume>1</volume>
<pages>521--528</pages>
<contexts>
<context position="6105" citStr="MacCartney and Manning (2008)" startWordPosition="935" endWordPosition="939">sification task. Among the most successful methods, Wan et al. (2006) enriched the feature set by the BLEU metric and dependency relations. Das and Smith (2009) used the quasi-synchronous grammar formalism to incorporate features from WordNet, named entity recognizer, POS tagger, and dependency labels from aligned trees. The task of recognizing textual entailment is to decide whether the hypothesis sentence can be entailed by the premise sentence (Giampiccolo et al., 2007). In recognizing textual entailment, de Marneffe et al. (2006) classified sentences pairs on the basis of word alignments. MacCartney and Manning (2008) used an inference procedure based on natural logic and combined it with the methods by de Marneffe et al. (2006). Harmeling (2007) and Heilman and Smith (2010) classified sequence pairs based on transformation on syntactic trees. Zanzotto et al. (2007) used a kernel method on syntactic tree pairs (Moschitti and Zanzotto, 2007). 3 Kernel Approach to Sentence Re-Writing Learning We formalize sentence re-writing learning as a kernel method. Following the literature of string kernel, we use the terms string and character instead of sentence and word. Suppose that we are given training data consis</context>
</contexts>
<marker>MacCartney, Manning, 2008</marker>
<rawString>MacCartney, B. and Manning, C.D. 2008. Modeling semantic containment and exclusion in natural language inference. Proceedings of the 22nd International Conference on Computational Linguistics, vol. 1, pp. 521-528, 2008.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Moschitti</author>
<author>F M Zanzotto</author>
</authors>
<title>Fast and Effective Kernels for Relational Learning from Texts.</title>
<date>2007</date>
<booktitle>Proceedings of the 24th Annual International Conference on Machine Learning,</booktitle>
<location>Corvallis, OR, USA,</location>
<contexts>
<context position="6434" citStr="Moschitti and Zanzotto, 2007" startWordPosition="988" endWordPosition="991">sk of recognizing textual entailment is to decide whether the hypothesis sentence can be entailed by the premise sentence (Giampiccolo et al., 2007). In recognizing textual entailment, de Marneffe et al. (2006) classified sentences pairs on the basis of word alignments. MacCartney and Manning (2008) used an inference procedure based on natural logic and combined it with the methods by de Marneffe et al. (2006). Harmeling (2007) and Heilman and Smith (2010) classified sequence pairs based on transformation on syntactic trees. Zanzotto et al. (2007) used a kernel method on syntactic tree pairs (Moschitti and Zanzotto, 2007). 3 Kernel Approach to Sentence Re-Writing Learning We formalize sentence re-writing learning as a kernel method. Following the literature of string kernel, we use the terms string and character instead of sentence and word. Suppose that we are given training data consisting of re-writings of strings and their responses ((s1,t1),y1),...,((sn,tn),yn) ( )Y where denotes the character set, = S i=0 i denotes the string set, which is the Kleene closure of set , Y denotes the set of responses, and n is the number of instances. (si,ti) is a re-writing consisting of the source string si and the target</context>
</contexts>
<marker>Moschitti, Zanzotto, 2007</marker>
<rawString>Moschitti, A. and Zanzotto, F.M. 2007. Fast and Effective Kernels for Relational Learning from Texts. Proceedings of the 24th Annual International Conference on Machine Learning, Corvallis, OR, USA, 2007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Qiu</author>
<author>M Y Kan</author>
<author>T S Chua</author>
</authors>
<title>Paraphrase recognition via dissimilarity significance classification.</title>
<date>2006</date>
<booktitle>Proceedings of the 2006 Conference on Empirical Methods in Natural Language Processing,</booktitle>
<pages>1826</pages>
<contexts>
<context position="5383" citStr="Qiu et al., 2006" startWordPosition="820" endWordPosition="823"> of paraphrase pattern generation and paraphrase identification. Paraphrase pattern generation is to automatically extract semantically equivalent patterns (Lin and Pantel, 2001; Bhagat and Ravichandran, 2008) or sentences (Barzilay and Lee, 2003). Paraphrase identification is to identify whether two given sentences are a paraphrase of each other. The methods proposed so far formalized the problem as classification and used various types of features such as bag-of-words feature, edit distance (Zhang and Patrick, 2005), dissimilarity kernel (Lintean and Rus, 2011) predicate-argument structure (Qiu et al., 2006), and tree edit model (which is based on a tree kernel) (Heilman and Smith, 2010) in the classification task. Among the most successful methods, Wan et al. (2006) enriched the feature set by the BLEU metric and dependency relations. Das and Smith (2009) used the quasi-synchronous grammar formalism to incorporate features from WordNet, named entity recognizer, POS tagger, and dependency labels from aligned trees. The task of recognizing textual entailment is to decide whether the hypothesis sentence can be entailed by the premise sentence (Giampiccolo et al., 2007). In recognizing textual entai</context>
<context position="25717" citStr="Qiu et al. (2006)" startWordPosition="4778" endWordPosition="4781">o included in Table 1. kb-SRK outperforms the existing lexical approach (Zhang and Patrick, 2005) and kernel approach (Lintean and Rus, 2011). It also works better than the other approaches listed in the table, which use syntactic trees or dependency relations. Fig. 7 gives detailed results of the kernels under different maximum k-gram lengths kmax with and without PR. The results of ps-SRK and pw-SRK without combining PR under different k are all below 71%, therefore they are not shown for clarMethod Acc. Zhang and Patrick (2005) 71.9 Lintean and Rus (2011) 73.6 Heilman and Smith (2010) 73.2 Qiu et al. (2006) 72.0 Wan et al. (2006) 75.6 Das and Smith (2009) 73.9 Das and Smith (2009)(PoE) 76.1 Our baseline (PR) 73.6 Our method (ps-SRK) 75.6 Our method (pw-SRK) 75.0 Our method (kb-SRK) 76.3 Table 1: Comparison with state-of-the-arts on MSRP. 455 \x0ca b *1 c 73.5 74 74.5 75 75.5 76 76.5 1 2 3 4 Accuracy (%) window size kmax kb_SRK+PR kb_SRK ps_SRK+PR pw_SRK+PR PR Figure 7: Performances of different kernels under different maximum window size kmax on MSRP. ity. By comparing the results of kb-SRK and pwSRK we can see that the bijective property in kbSRK is really helpful for improving the performance </context>
</contexts>
<marker>Qiu, Kan, Chua, 2006</marker>
<rawString>Qiu, L. and Kan, M.Y. and Chua, T.S. 2006. Paraphrase recognition via dissimilarity significance classification. Proceedings of the 2006 Conference on Empirical Methods in Natural Language Processing, pp. 1826.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Brockett</author>
<author>W Dolan</author>
</authors>
<title>Monolingual machine translation for paraphrase generation.</title>
<date>2004</date>
<marker>Brockett, Dolan, 2004</marker>
<rawString>Quirk, C. , Brockett, C. and Dolan, W. 2004. Monolingual machine translation for paraphrase generation.</rawString>
</citation>
<citation valid="true">
<date></date>
<booktitle>Proceedings of EMNLP 2004,</booktitle>
<pages>142--149</pages>
<location>Barcelona,</location>
<marker></marker>
<rawString>Proceedings of EMNLP 2004, pp. 142-149, Barcelona, Spain.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Scholkopf</author>
<author>A J Smola</author>
</authors>
<title>Learning with kernels: Support vector machines, regularization, optimization, and beyond.</title>
<date>2002</date>
<publisher>The MIT Press,</publisher>
<location>Cambridge, MA.</location>
<contexts>
<context position="2704" citStr="Scholkopf and Smola, 2002" startWordPosition="404" endWordPosition="407">espeare. (B) * * * * (A) Figure 1: Example of re-writing. (A) is a re-writing rule and (B) is a re-writing of sentence. 2009; Heilman and Smith, 2010) of the sentence pairs. In (Lin and Pantel, 2001; Barzilay and Lee, 2003), re-writing rules serve as underlying representations for paraphrase generation/discovery. Motivated by the work, we represent re-writing of sentences by all possible re-writing rules that can be applied into it. For example, in Fig. 1, (A) is one re-writing rule that can be applied into the sentence re-writing (B). Specifically, we propose a new class of kernel functions (Scholkopf and Smola, 2002), called string rewriting kernel (SRK), which defines the similarity between two re-writings (pairs) of strings as the inner product between them in the feature space induced by all the re-writing rules. SRK is different from existing kernels in that it is for re-writing and defined on two pairs of strings. SRK can capture the lexical and structural similarity between re-writings of sentences and does not need to parse the sentences and create the syntactic trees of them. One challenge for using SRK lies in the high computational cost of straightforwardly computing the kernel, because it invol</context>
<context position="7859" citStr="Scholkopf and Smola, 2002" startWordPosition="1234" endWordPosition="1237">ting (s,t) , our goal is to predict its response y. That is, the training data consists of binary classes of string re-writings, and the prediction is made for the new re-writing based on learning from the training data. We take the kernel approach to address the learning task. The kernel on re-writings of strings is defined as K : ( )( ) R satisfying for all (si,ti), (sj,tj) , K((si,ti),(sj,tj)) = h(si,ti),(sj,tj)i where maps each re-writing (pair) of strings into a high dimensional Hilbert space H , referred to as 450 \x0cfeature space. By the representer theorem (Kimeldorf and Wahba, 1971; Scholkopf and Smola, 2002), it can be shown that the response y of a new string re-writing (s,t) can always be represented as y = sign( n i=1 iyiK((si,ti),(s,t))) where i 0,(i = 1, ,n) are parameters. That is, it is determined by a linear combination of the similarities between the new instance and the instances in training set. It is also known that by employing a learning model such as SVM (Vapnik, 2000), such a linear combination can be automatically learned by solving a quadratic optimization problem. The question then becomes how to design the kernel function for the task. 4 String Re-writing Kernel Let be the set</context>
</contexts>
<marker>Scholkopf, Smola, 2002</marker>
<rawString>Scholkopf, B. and Smola, A.J. 2002. Learning with kernels: Support vector machines, regularization, optimization, and beyond. The MIT Press, Cambridge, MA.</rawString>
</citation>
<citation valid="true">
<authors>
<author>V N Vapnik</author>
</authors>
<title>The nature of statistical learning theory.</title>
<date>2000</date>
<publisher>Springer Verlag.</publisher>
<contexts>
<context position="8242" citStr="Vapnik, 2000" startWordPosition="1307" endWordPosition="1308">j)) = h(si,ti),(sj,tj)i where maps each re-writing (pair) of strings into a high dimensional Hilbert space H , referred to as 450 \x0cfeature space. By the representer theorem (Kimeldorf and Wahba, 1971; Scholkopf and Smola, 2002), it can be shown that the response y of a new string re-writing (s,t) can always be represented as y = sign( n i=1 iyiK((si,ti),(s,t))) where i 0,(i = 1, ,n) are parameters. That is, it is determined by a linear combination of the similarities between the new instance and the instances in training set. It is also known that by employing a learning model such as SVM (Vapnik, 2000), such a linear combination can be automatically learned by solving a quadratic optimization problem. The question then becomes how to design the kernel function for the task. 4 String Re-writing Kernel Let be the set of characters and be the set of strings. Let wildcard domain D be the set of strings which can be replaced by wildcards. The string re-writing kernel measures the similarity between two string re-writings through the rewriting rules that can be applied into them. Formally, given re-writing rule set R and wildcard domain D, the string re-writing kernel (SRK) is defined as K((s1,t1</context>
</contexts>
<marker>Vapnik, 2000</marker>
<rawString>Vapnik, V.N. 2000. The nature of statistical learning theory. Springer Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Dras</author>
</authors>
<title>Using dependency-based features to take the Para-farce out of paraphrase.</title>
<date>2006</date>
<booktitle>Proc. of the Australasian Language Technology Workshop,</booktitle>
<pages>131138</pages>
<marker>Dras, 2006</marker>
<rawString>Wan, S. , Dras, M. , Dale, R. and Paris, C. 2006. Using dependency-based features to take the Para-farce out of paraphrase. Proc. of the Australasian Language Technology Workshop, pp. 131138.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Pennacchiotti</author>
<author>A Moschitti</author>
</authors>
<title>Shallow semantics in fast textual entailment \x0crule learners.</title>
<date>2007</date>
<booktitle>Proceedings of the ACL-PASCAL workshop on textual entailment and paraphrasing,</booktitle>
<pages>7277</pages>
<marker>Pennacchiotti, Moschitti, 2007</marker>
<rawString>Zanzotto, F.M. , Pennacchiotti, M. and Moschitti, A. 2007. Shallow semantics in fast textual entailment \x0crule learners. Proceedings of the ACL-PASCAL workshop on textual entailment and paraphrasing, pp. 7277.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Zhang</author>
<author>J Patrick</author>
</authors>
<title>Paraphrase identification by text canonicalization.</title>
<date>2005</date>
<booktitle>Proceedings of the Australasian Language Technology Workshop,</booktitle>
<pages>160--166</pages>
<contexts>
<context position="1909" citStr="Zhang and Patrick, 2005" startWordPosition="270" endWordPosition="273">he-art methods on two sentence re-writing learning tasks: paraphrase identification and recognizing textual entailment. 1 Introduction Learning for sentence re-writing is a fundamental task in natural language processing and information retrieval, which includes paraphrasing, textual entailment and transformation between query and document title in search. The key question here is how to represent the rewriting of sentences. In previous research on sentence re-writing learning such as paraphrase identification and recognizing textual entailment, most representations are based on the lexicons (Zhang and Patrick, 2005; Lintean and Rus, 2011; de Marneffe et al., 2006) or the syntactic trees (Das and Smith, wrote . Shakespeare wrote Hamlet. * was written by . Hamlet was written by Shakespeare. (B) * * * * (A) Figure 1: Example of re-writing. (A) is a re-writing rule and (B) is a re-writing of sentence. 2009; Heilman and Smith, 2010) of the sentence pairs. In (Lin and Pantel, 2001; Barzilay and Lee, 2003), re-writing rules serve as underlying representations for paraphrase generation/discovery. Motivated by the work, we represent re-writing of sentences by all possible re-writing rules that can be applied int</context>
<context position="5289" citStr="Zhang and Patrick, 2005" startWordPosition="808" endWordPosition="811">d Noble, 2005) or Cartesian product (Kashima et al., 2009). The task of paraphrasing usually consists of paraphrase pattern generation and paraphrase identification. Paraphrase pattern generation is to automatically extract semantically equivalent patterns (Lin and Pantel, 2001; Bhagat and Ravichandran, 2008) or sentences (Barzilay and Lee, 2003). Paraphrase identification is to identify whether two given sentences are a paraphrase of each other. The methods proposed so far formalized the problem as classification and used various types of features such as bag-of-words feature, edit distance (Zhang and Patrick, 2005), dissimilarity kernel (Lintean and Rus, 2011) predicate-argument structure (Qiu et al., 2006), and tree edit model (which is based on a tree kernel) (Heilman and Smith, 2010) in the classification task. Among the most successful methods, Wan et al. (2006) enriched the feature set by the BLEU metric and dependency relations. Das and Smith (2009) used the quasi-synchronous grammar formalism to incorporate features from WordNet, named entity recognizer, POS tagger, and dependency labels from aligned trees. The task of recognizing textual entailment is to decide whether the hypothesis sentence ca</context>
<context position="25197" citStr="Zhang and Patrick, 2005" startWordPosition="4689" endWordPosition="4692">6.1 Paraphrase Identification The task of paraphrase identification is to examine whether two sentences have the same meaning. We trained and tested all the methods on the MSR Paraphrase Corpus (Dolan and Brockett, 2005; Quirk et al., 2004) consisting of 4,076 sentence pairs for training and 1,725 sentence pairs for testing. The experimental results on different SRKs are shown in Table 1. It can be seen that kb-SRK outperforms ps-SRK and pw-SRK. The results by the state-of-the-art methods reported in previous work are also included in Table 1. kb-SRK outperforms the existing lexical approach (Zhang and Patrick, 2005) and kernel approach (Lintean and Rus, 2011). It also works better than the other approaches listed in the table, which use syntactic trees or dependency relations. Fig. 7 gives detailed results of the kernels under different maximum k-gram lengths kmax with and without PR. The results of ps-SRK and pw-SRK without combining PR under different k are all below 71%, therefore they are not shown for clarMethod Acc. Zhang and Patrick (2005) 71.9 Lintean and Rus (2011) 73.6 Heilman and Smith (2010) 73.2 Qiu et al. (2006) 72.0 Wan et al. (2006) 75.6 Das and Smith (2009) 73.9 Das and Smith (2009)(PoE)</context>
</contexts>
<marker>Zhang, Patrick, 2005</marker>
<rawString>Zhang, Y. and Patrick, J. 2005. Paraphrase identification by text canonicalization. Proceedings of the Australasian Language Technology Workshop, pp. 160 166.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>